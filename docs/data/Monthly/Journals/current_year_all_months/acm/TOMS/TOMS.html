<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>TOMS</title>
  <style>
    html {font-size: 22px;}
    body {margin: 0 auto; max-width: 76em;}
    #copyID {font-size: 18px;}
  </style>
  <script>
    function copy(element) {
      if (element.type == "button"){
      element.type="text";
      }
      element.style.color="black";
      element.style.backgroundColor="#C7EDCC";
      element.select();
      element.setSelectionRange(0, 99999);
      navigator.clipboard.writeText(element.value);
      window.getSelection().removeAllRanges();
      element.type="button";
    }
  </script>
</head>
<body>

<h2 id="toms">TOMS - 21</h2>
<ul>
<li><details>
<summary>
(2025). A massively parallel performance portable free-space spectral poisson solver. <em>TOMS</em>, <em>51</em>(3), 1-23. (<a href='https://doi.org/10.1145/3748815'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Vico et al. suggest a fast algorithm for computing volume potentials, beneficial to fields with problems requiring the solution of the free-space Poisson’s equation, such as beam and plasma physics. Currently, the standard is the algorithm of Hockney and Eastwood, with second order in convergence at best. The algorithm proposed by Vico et al. converges spectrally for sufficiently smooth functions, i.e., faster than any fixed order in the number of grid points. We implement a performance portable version of the traditional Hockney-Eastwood and the novel Vico-Greengard Poisson solver as part of the Independent Parallel Particle Layer (IPPL) library. For sufficiently smooth source functions, the Vico-Greengard algorithm achieves higher accuracy than the Hockney-Eastwood method with the same grid size, reducing the computational demands of high-resolution simulations since one could use coarser grids to achieve them. Additionally, we propose an improvement to the Vico-Greengard method which further reduces its memory footprint. This is important for GPUs, which have limited memory, and should be taken into account when selecting numerical algorithms for performance portable codes. Finally, we showcase performance through GPU and CPU scaling studies on the Perlmutter (NERSC) supercomputer, with efficiencies staying above 50% in the strong scaling case. To showcase portability, we also run the scaling studies on the Alps supercomputer at CSCS, Switzerland and the GPU partition of the Lumi supercomputer at CSC, Finland.},
  archive      = {J_TOMS},
  author       = {Sonali Mayani and Veronica Montanaro and Antoine Cerfon and Matthias Frey and Sriramkrishnan Muralikrishnan and Andreas Adelmann},
  doi          = {10.1145/3748815},
  journal      = {ACM Transactions on Mathematical Software},
  month        = {9},
  number       = {3},
  pages        = {1-23},
  shortjournal = {ACM Trans. Math. Softw.},
  title        = {A massively parallel performance portable free-space spectral poisson solver},
  volume       = {51},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). FIAT: Improving performance and accuracy for high-order finite elements. <em>TOMS</em>, <em>51</em>(3), 1-17. (<a href='https://doi.org/10.1145/3748816'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {FIAT (the FInite element Automatic Tabulator) provides a powerful Python library for the generation and evaluation of finite element basis functions on a reference element. This release paper describes recent improvements to FIAT aimed at improving its run time and the accuracy and efficiency of code generated using FIAT-provided information. In the first category, we have greatly streamlined the implementation of orthogonal polynomials out of which finite element bases are built. The second category comprises several more advances. For one, we have built an interface to the recursivenodes package to enable more accurate Lagrange bases at high order. We have also implemented integral-type degrees of freedom for \(H(\operatorname{div})\) and \(H(\operatorname{curl})\) elements, which match the mathematical definitions of the elements more closely and also avoid loss of accuracy in interpolation. More fundamentally, we have included families of simplicial quadrature rules that require many fewer quadrature points than the Stroud rules previously used in FIAT. Finally, FIAT now provides support for fast diagonalization methods, which enable fast solution algorithms at very high order. In each case, we describe the new features in FIAT and illustrate some of the gains obtained through simple numerical tests.},
  archive      = {J_TOMS},
  author       = {Pablo D. Brubeck and Robert C. Kirby and Fabian Laakmann and Lawrence Mitchell},
  doi          = {10.1145/3748816},
  journal      = {ACM Transactions on Mathematical Software},
  month        = {9},
  number       = {3},
  pages        = {1-17},
  shortjournal = {ACM Trans. Math. Softw.},
  title        = {FIAT: Improving performance and accuracy for high-order finite elements},
  volume       = {51},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Towards seamless interoperability of MPI-OpenMP applications. <em>TOMS</em>, <em>51</em>(3), 1-13. (<a href='https://doi.org/10.1145/3757913'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A chasm exists between mathematical software libraries written for MPI-based applications and those written for OpenMP applications. Recently, however, PETSc enables the simple use of its MPI-based linear solvers from OpenMP applications. Separately, the MPICH MPI development team has started a new project to allow almost seamless MPI use in OpenMP applications. Both proposed approaches would result in a similar user experience. We discuss the reasons for these projects and their potential for providing more numerical library choices for OpenMP applications, including the unlimited assortment of linear solvers available in PETSc. In addition, we present the performance of an application using the first approach, demonstrating its efficacy.},
  archive      = {J_TOMS},
  author       = {Barry Smith and Marsha Berger and Junchao Zhang and Hui Zhou},
  doi          = {10.1145/3757913},
  journal      = {ACM Transactions on Mathematical Software},
  month        = {9},
  number       = {3},
  pages        = {1-13},
  shortjournal = {ACM Trans. Math. Softw.},
  title        = {Towards seamless interoperability of MPI-OpenMP applications},
  volume       = {51},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). TorchBraid: High-performance layer-parallel training of deep neural networks with MPI and GPU acceleration. <em>TOMS</em>, <em>51</em>(3), 1-30. (<a href='https://doi.org/10.1145/3759244'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {TorchBraid is a high-performance implementation of layer-parallel training for deep neural networks (DNNs) supporting MPI-based parallelism and GPU acceleration. Layer-parallel training has been developed to overcome the serialization inherent in forward and backward propagation of DNNs that limits utilization of computational resources in the strong scaling limit. To achieve this, TorchBraid integrates the PyTorch neural network framework with the state-of-the-art XBraid time-parallel library. This article presents the use and performance of TorchBraid, in addition to solutions for overcoming the algorithmic challenges inherent in combining automatic differentiation with layer-parallel. Results are presented with and without GPU acceleration for the Tiny ImageNet and MNIST image classification data sets, as well as recurrent neural networks. Overall, TorchBraid enables fast training of DNNs, both in a strong and weak scaling context. In addition to the TorchBraid software, several new advances in applying layer-parallel algorithms are detailed. Integration of layer-parallel with data-parallel algorithms is presented for the first time, showing the computational advantages of the combination. Standard deep learning techniques, like batch-normalization, are developed for layer-parallel training. Finally, a new approach combining layer-parallel with spatial coarsening in order to accelerate training for 3D image classification shows roughly a 10× speedup over serial execution.},
  archive      = {J_TOMS},
  author       = {Eric C. Cyr and Jens Hahne and Nicholas S. Moore and Jacob B. Schroder and Ben S. Southworth and David A. Vargas},
  doi          = {10.1145/3759244},
  journal      = {ACM Transactions on Mathematical Software},
  month        = {9},
  number       = {3},
  pages        = {1-30},
  shortjournal = {ACM Trans. Math. Softw.},
  title        = {TorchBraid: High-performance layer-parallel training of deep neural networks with MPI and GPU acceleration},
  volume       = {51},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Extending irksome: Improvements in automated Runge–Kutta time stepping for finite element methods. <em>TOMS</em>, <em>51</em>(3), 1-27. (<a href='https://doi.org/10.1145/3759245'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Irksome is a library based on the Unified Form Language (UFL) that enables automated generation of Runge–Kutta methods for time-stepping finite element spatial discretizations of Partial Differential Equations (PDEs). Allowing users to express semidiscrete forms of PDEs, it generates UFL representations for the stage-coupled variational problems to be solved at each timestep. The Firedrake package then generates efficient code for evaluating these variational problems and allows users a wide range of options to deploy efficient algebraic solvers in PETSc. In this article, we describe several recent advances in Irksome . These include alternate formulations of the Runge–Kutta time-stepping methods and optimized support for diagonally implicit (DIRK) methods. Additionally, we present new and improved tools for building preconditioners for the resulting linear and linearized systems, demonstrating that these can lead to efficient approaches for solving fully implicit Runge–Kutta discretizations. The new features are demonstrated through a sequence of computational examples demonstrating the high-level interface and obtained solver performance.},
  archive      = {J_TOMS},
  author       = {Robert C. Kirby and Scott P. MacLachlan},
  doi          = {10.1145/3759245},
  journal      = {ACM Transactions on Mathematical Software},
  month        = {9},
  number       = {3},
  pages        = {1-27},
  shortjournal = {ACM Trans. Math. Softw.},
  title        = {Extending irksome: Improvements in automated Runge–Kutta time stepping for finite element methods},
  volume       = {51},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Algorithm 1058: Computing the group of local dyadic square-classes the easy way. <em>TOMS</em>, <em>51</em>(3), 1-14. (<a href='https://doi.org/10.1145/3759246'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We propose a novel method for constructing a basis of the group of local square-classes of a dyadic completion of a number field. The described method has been implemented by the author in the computer algebra systems Magma and SageMath. It turned out to be substantially faster than the algorithm previously used. The article presents the algorithm itself, together with a time comparison with the preexisting solution.},
  archive      = {J_TOMS},
  author       = {Przemysław Koprowski},
  doi          = {10.1145/3759246},
  journal      = {ACM Transactions on Mathematical Software},
  month        = {9},
  number       = {3},
  pages        = {1-14},
  shortjournal = {ACM Trans. Math. Softw.},
  title        = {Algorithm 1058: Computing the group of local dyadic square-classes the easy way},
  volume       = {51},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Multilevel interior penalty methods on GPUs. <em>TOMS</em>, <em>51</em>(3), 1-27. (<a href='https://doi.org/10.1145/3765616'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We present a matrix-free multigrid method for high-order Discontinuous Galerkin (DG) finite element methods with GPU acceleration. A performance analysis is conducted, comparing various data and compute layouts. Smoother implementations are optimized through localization and fast diagonalization techniques. Leveraging conflict-free access patterns in shared memory, arithmetic throughput of up to 40% of the peak performance on NVIDIA A100 GPUs are achieved. Experimental results affirm the effectiveness of mixed-precision approaches and Message Passing Interface (MPI) parallelization in accelerating algorithms. Furthermore, an assessment of solver efficiency and robustness is provided across both two and three dimensions, with applications to Poisson problems.},
  archive      = {J_TOMS},
  author       = {Cu Cui and Guido Kanschat},
  doi          = {10.1145/3765616},
  journal      = {ACM Transactions on Mathematical Software},
  month        = {9},
  number       = {3},
  pages        = {1-27},
  shortjournal = {ACM Trans. Math. Softw.},
  title        = {Multilevel interior penalty methods on GPUs},
  volume       = {51},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Algorithm 1055: HDSDP: Software for semidefinite programming. <em>TOMS</em>, <em>51</em>(2), 1-30. (<a href='https://doi.org/10.1145/3721123'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {HDSDP is a numerical software solving semidefinite programming problems. The main framework of HDSDP resembles the dual-scaling interior point solver DSDP and several new features, including a dual method based on the simplified homogeneous self-dual embedding, have been implemented. The embedding technique enhances the stability of the dual method, and several new heuristics and computational techniques are designed to accelerate its convergence. HDSDP aims to show how the dual-scaling algorithm benefits from the self-dual embedding, and it is developed in parallel to DSDP 5.8. Numerical experiments over several classical benchmark datasets exhibit their robustness and efficiency, particularly their advantages on SDP instances featuring low-rank structure and sparsity. HDSDP is open sourced under an MIT license and available at https://github.com/Gwzwpxz/HDSDP .},
  archive      = {J_TOMS},
  author       = {Wenzhi Gao and Dongdong Ge and Yinyu Ye},
  doi          = {10.1145/3721123},
  journal      = {ACM Transactions on Mathematical Software},
  month        = {6},
  number       = {2},
  pages        = {1-30},
  shortjournal = {ACM Trans. Math. Softw.},
  title        = {Algorithm 1055: HDSDP: Software for semidefinite programming},
  volume       = {51},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Approximating large-scale hessian matrices using secant equations. <em>TOMS</em>, <em>51</em>(2), 1-21. (<a href='https://doi.org/10.1145/3728460'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Large-scale optimization algorithms frequently require sparse Hessian matrices that are not readily available. Existing methods for approximating large sparse Hessian matrices either do not impose sparsity or are computationally prohibitive. To try and overcome these limitations, we propose a novel approach that seeks to satisfy as many componentwise secant equations as necessary to define each row of the Hessian matrix. A naive application of this approach is too expensive for Hessian matrices that have some relatively dense rows but, by carefully taking into account the symmetry and connectivity of the Hessian matrix, we are able devise an approximation algorithm that is fast and efficient with scope for parallelism. Example sparse Hessian matrices from the CUTEst test collection for optimization illustrate the effectiveness and robustness of our proposed method.},
  archive      = {J_TOMS},
  author       = {Jaroslav M. Fowkes and Nicholas I. M. Gould and Jennifer A. Scott},
  doi          = {10.1145/3728460},
  journal      = {ACM Transactions on Mathematical Software},
  month        = {6},
  number       = {2},
  pages        = {1-21},
  shortjournal = {ACM Trans. Math. Softw.},
  title        = {Approximating large-scale hessian matrices using secant equations},
  volume       = {51},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Intersection of tetrahedra. <em>TOMS</em>, <em>51</em>(2), 1-26. (<a href='https://doi.org/10.1145/3729532'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {When intersecting non-matching three-dimensional lattices, one needs to calculate the intersections of tetrahedra. The authors’ previously published two-dimensional triangle–triangle intersection algorithm suggests a novel approach in three dimensions based on parsimony. The algorithm presented here expands on this two-dimensional algorithm and introduces new strategies necessitated by the increase in dimension. An extensive proof is given for the consistency of the algorithm. Thus, the algorithm is shown to be robust to numerical error arising from floating-point arithmetic. Example problems demonstrate its use and effectiveness.},
  archive      = {J_TOMS},
  author       = {Conor McCoid and Martin J. Gander},
  doi          = {10.1145/3729532},
  journal      = {ACM Transactions on Mathematical Software},
  month        = {6},
  number       = {2},
  pages        = {1-26},
  shortjournal = {ACM Trans. Math. Softw.},
  title        = {Intersection of tetrahedra},
  volume       = {51},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). LevelSetPy: A GPU-accelerated package for hyperbolic Hamilton–Jacobi partial differential equations. <em>TOMS</em>, <em>51</em>(2), 1-14. (<a href='https://doi.org/10.1145/3730407'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {This article introduces a software package release for geometrically reasoning about the safety desiderata of (complex) dynamical systems via level set methods. In emphasis, safety is analyzed with the Hamilton–Jacobi equations. In scope, we provide implementations of numerical algorithms for the resolution of Hamilton–Jacobi–Isaacs equations: the spatial derivatives of the associated value function via upwinding, the Hamiltonian via Lax–Friedrichs schemes, and the integration of the Hamilton–Jacobi equation altogether via total variation diminishing Runge–Kutta schemes. Since computational speed and interoperability with other modern scientific computing libraries (typically written in the Python language) are of essence, we capitalize on modern computational frameworks such as CUPY and NUMPY and move heavy computations to GPU devices to aid parallelization and improve bring-up time in safety analysis. We hope that this package can aid users to quickly iterate on ideas and evaluate all possible safety desiderata of a system via geometrical simulation in modern engineering problems.},
  archive      = {J_TOMS},
  author       = {Lekan Molu},
  doi          = {10.1145/3730407},
  journal      = {ACM Transactions on Mathematical Software},
  month        = {6},
  number       = {2},
  pages        = {1-14},
  shortjournal = {ACM Trans. Math. Softw.},
  title        = {LevelSetPy: A GPU-accelerated package for hyperbolic Hamilton–Jacobi partial differential equations},
  volume       = {51},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Algorithm 1056: QPoly—A magma package for working with quaternionic polynomials. <em>TOMS</em>, <em>51</em>(2), 1-14. (<a href='https://doi.org/10.1145/3731677'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The article presents the package for the computer algebra system Magma . It is a collection of functions for manipulating quaternionic polynomials over number fields. It provides nearly the same functionality for quaternionic polynomials as the ones provided by Magma for polynomials over fields.},
  archive      = {J_TOMS},
  author       = {Przemysław Koprowski},
  doi          = {10.1145/3731677},
  journal      = {ACM Transactions on Mathematical Software},
  month        = {6},
  number       = {2},
  pages        = {1-14},
  shortjournal = {ACM Trans. Math. Softw.},
  title        = {Algorithm 1056: QPoly—A magma package for working with quaternionic polynomials},
  volume       = {51},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Algorithm 1057: FunC: A minimally invasive c++ library for the generation and analysis of univariate lookup tables. <em>TOMS</em>, <em>51</em>(2), 1-30. (<a href='https://doi.org/10.1145/3734692'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A Lookup Table (LUT) is a computationally inexpensive piecewise function used to approximate computationally expensive mathematical functions. Evaluating a LUT can be as quick as using Horner’s method to evaluate a polynomial after looking up its coefficients. A common choice of LUT is a piecewise constant or piecewise linear function; however, high-degree interpolating polynomials can also be valuable. Here, we describe the functionality of FunC 2.0, a C++ library designed to streamline the process of building, comparing, and implementing univariate LUTs in practical applications. In particular, FunC 2.0 can build relatively small LUTs satisfying user-provided absolute and relative tolerances for error. Furthermore, FunC 2.0 can build nonuniform LUTs, it provides utilities to quickly determine reasonable LUT bounds and tolerances for error, and it provides a way to quickly profile a set of LUTs. We demonstrate FunC ’s utility in application by reducing the total runtime of a simulation performed by the Canadian Hydrological Model (CHM). This simulation modeled the snow mass distribution across Western Canada over 1 month. Now, the CHM can evaluate the mathematical function of interest about 28 times faster, allowing the necessary algorithm to finish two times faster, and the overall simulation is about 9% faster.},
  archive      = {J_TOMS},
  author       = {Shawn S. C. McAdam and Raymond J. Spiteri},
  doi          = {10.1145/3734692},
  journal      = {ACM Transactions on Mathematical Software},
  month        = {6},
  number       = {2},
  pages        = {1-30},
  shortjournal = {ACM Trans. Math. Softw.},
  title        = {Algorithm 1057: FunC: A minimally invasive c++ library for the generation and analysis of univariate lookup tables},
  volume       = {51},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Symbolic and user-friendly geometric algebra routines (SUGAR) for computations in matlab. <em>TOMS</em>, <em>51</em>(2), 1-31. (<a href='https://doi.org/10.1145/3734693'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Geometric Algebra (GA) provides a unified, compact mathematical framework for geometric computing, simplifying relations typically handled with more complex tools like matrix multiplication. In fields like robotics, GA replaces conventional coordinate-based approaches with the multiplication of special elements called rotors, offering greater efficiency. Despite its advantages, GA’s complexity and the lack of symbolic tools hinder its broader adoption among applied mathematicians and engineers. To address this, this article introduces Symbolic and User-friendly Geometric Algebra Routines (SUGAR), an open source Matlab toolbox. SUGAR streamlines GA usage in Matlab through a collection of user-friendly functions that support both numeric and symbolic computations, even in high-dimensional algebras. Designed for applied mathematics and engineering, it enables intuitive manipulation of geometric elements and transformations in two- and three-dimensional projective and conformal GAs, consistent with established computational methods. Moreover, SUGAR manages multivector functions such as exponential, logarithmic, sinusoidal, and cosine operations, enhancing its applicability in domains like robotics, control systems, and power electronics. Finally, this article also presents three validation examples across these fields, showcasing SUGAR’s practical utility in solving real-world engineering and applied mathematics problems.},
  archive      = {J_TOMS},
  author       = {Manel Velasco and Isiah Zaplana and Arnau Dòria-Cerezo and Pau Martí},
  doi          = {10.1145/3734693},
  journal      = {ACM Transactions on Mathematical Software},
  month        = {6},
  number       = {2},
  pages        = {1-31},
  shortjournal = {ACM Trans. Math. Softw.},
  title        = {Symbolic and user-friendly geometric algebra routines (SUGAR) for computations in matlab},
  volume       = {51},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Forward-mode automatic differentiation of compiled programs. <em>TOMS</em>, <em>51</em>(2), 1-25. (<a href='https://doi.org/10.1145/3716309'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Algorithmic differentiation (AD) is a set of techniques that provide partial derivatives of computer-implemented functions. Such functions can be supplied to state-of-the-art AD tools via their source code , or via intermediate representations produced while compiling their source code. We present the novel AD tool Derivgrind, which augments the machine code of compiled programs with forward-mode AD logic. Derivgrind leverages the Valgrind instrumentation framework for structured access to the machine code, and a shadow memory tool to store dot values. Access to the source code is required at most for the files in which input and output variables are defined. Derivgrind’s versatility mainly comes at the price of reduced run-time performance. According to our extensive regression test suite, Derivgrind produces correct results on GCC- and Clang-compiled programs, including a Python interpreter, with a small number of exceptions. We provide a list of “bit-tricks” that Derivgrind does not handle correctly, some of which actually appear in highly optimized math libraries. As long as differentiating those is avoided, Derivgrind enables black-box forward-mode AD for an unprecedentedly wide range of cross-language software with little integration efforts.},
  archive      = {J_TOMS},
  author       = {Max Aehle and Johannes Blühdorn and Max Sagebaum and Nicolas R. Gauger},
  doi          = {10.1145/3716309},
  journal      = {ACM Transactions on Mathematical Software},
  month        = {5},
  number       = {2},
  pages        = {1-25},
  shortjournal = {ACM Trans. Math. Softw.},
  title        = {Forward-mode automatic differentiation of compiled programs},
  volume       = {51},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Algorithm 1054: , a fortran software library for legendre elliptic integrals and jacobi elliptic functions with generalized input arguments. <em>TOMS</em>, <em>51</em>(1), 1-17. (<a href='https://doi.org/10.1145/3709136'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Legendre elliptic integrals and Jacobi elliptic functions arise in multiple applications within the physical sciences, including oscillations, celestial mechanics, and geodynamics. In this study, we describe the Fortran library ellipFor capable of evaluating the following for generalized input values: (1) the complete Legendre elliptic integrals of the first and second kinds, (2) the incomplete Legendre elliptic integrals of the first and second kinds, and (3) the principal Jacobi elliptic functions. Our software builds upon previously developed Fortran routines, which were designed with restrictions on input parameters that may be limiting in applications. Our routines apply multiple transformations to allow for more general input values, such as elliptic moduli greater than unity for points 1–3, arbitrary real Jacobi amplitudes for points 1–2, and complex first arguments for point 3. In addition, our routines are thread-safe, allowing for parallel computations. Our routines were compared with values from the computer algebra system SageMath over a wide range of input parameters. Values from ellipFor and SageMath agreed to within tolerances commensurate with the limitations of floating-point arithmetic used for the elliptic integrals and Jacobi elliptic functions listed in points 1, 2, and 3 above for generalized input arguments.},
  archive      = {J_TOMS},
  author       = {Sean J. Trim and Raymond J. Spiteri},
  doi          = {10.1145/3709136},
  journal      = {ACM Transactions on Mathematical Software},
  month        = {4},
  number       = {1},
  pages        = {1-17},
  shortjournal = {ACM Trans. Math. Softw.},
  title        = {Algorithm 1054: , a fortran software library for legendre elliptic integrals and jacobi elliptic functions with generalized input arguments},
  volume       = {51},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). A simple, scalable large deformation solid mechanics implementation in the MOOSE framework. <em>TOMS</em>, <em>51</em>(1), 1-22. (<a href='https://doi.org/10.1145/3716308'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {This article describes a large deformation solid mechanics solver implemented as part of the freely available and open source MOOSE finite element simulation framework. The article documents the choices made in developing the solid mechanics framework and describes novel formulations for the gradient operator and constitutive modeling framework made to simplify implementations of different coordinate systems, stabilized gradient operators, and different constitutive model inputs and outputs. In the process, the article describes a new formulation that casts objective integration of the Cauchy stress as a linear transformation of the small stress rate. Finally, the article presents key implementation details and examines the parallel efficiency of the solid mechanics solver implemented in MOOSE. The implementation retains a good weak scaling efficiency beyond 1,000 parallel processes. The article includes a discussion of the factors limiting the parallel efficiency of implicit, large deformation solid mechanics codes on current high-performance computers, with the main current limitation being the scalability of the algebraic multigrid methods used to solve the linearized equilibrium equations.},
  archive      = {J_TOMS},
  author       = {Tianchen Hu and Mark C. Messner},
  doi          = {10.1145/3716308},
  journal      = {ACM Transactions on Mathematical Software},
  month        = {4},
  number       = {1},
  pages        = {1-22},
  shortjournal = {ACM Trans. Math. Softw.},
  title        = {A simple, scalable large deformation solid mechanics implementation in the MOOSE framework},
  volume       = {51},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). : Discontinuous polytopal methods for multi-physics differential problems. <em>TOMS</em>, <em>51</em>(1), 1-22. (<a href='https://doi.org/10.1145/3716310'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We present the library lymph for the finite element numerical discretization of coupled multi-physics problems. lymph is a MATLAB library for the discretization of partial differential equations based on high-order discontinuous Galerkin methods on polytopal grids (PolyDG) for spatial discretization coupled with suitable finite-difference time marching schemes. The objective of the article is to introduce the library by describing it in terms of installation, input/output data, and code structure, highlighting—when necessary—key implementation aspects related to the method. A user guide, proceeding step-by-step in the implementation and solution of a Poisson problem, is also provided. In the last part of the article, we show the results obtained for several differential problems, namely the Poisson problem, the heat equation, the elastodynamics system, and a multi-physics problem coupling poroelasticity and acoustic equations. Through these examples, we show the convergence properties and highlight some of the main features of the proposed method, i.e., geometric flexibility, high-order accuracy, and robustness with respect to heterogeneous physical parameters.},
  archive      = {J_TOMS},
  author       = {Paola F. Antonietti and Stefano Bonetti and Michele Botti and Mattia Corti and Ivan Fumagalli and Ilario Mazzieri},
  doi          = {10.1145/3716310},
  journal      = {ACM Transactions on Mathematical Software},
  month        = {4},
  number       = {1},
  pages        = {1-22},
  shortjournal = {ACM Trans. Math. Softw.},
  title        = {: Discontinuous polytopal methods for multi-physics differential problems},
  volume       = {51},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). A mixed precision jacobi SVD algorithm. <em>TOMS</em>, <em>51</em>(1), 1-33. (<a href='https://doi.org/10.1145/3721124'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We propose a mixed precision Jacobi algorithm for computing the singular value decomposition (SVD) of a dense matrix. After appropriate preconditioning, the proposed algorithm computes the SVD in a lower precision as an initial guess and then performs one-sided Jacobi rotations in the working precision as iterative refinement. By carefully transforming a lower precision solution to a higher precision one, our algorithm achieves about \(2\times\) speedup on the x86-64 architecture compared to the usual one-sided Jacobi SVD algorithm in LAPACK, without sacrificing the accuracy.},
  archive      = {J_TOMS},
  author       = {Weiguo Gao and Yuxin Ma and Meiyue Shao},
  doi          = {10.1145/3721124},
  journal      = {ACM Transactions on Mathematical Software},
  month        = {4},
  number       = {1},
  pages        = {1-33},
  shortjournal = {ACM Trans. Math. Softw.},
  title        = {A mixed precision jacobi SVD algorithm},
  volume       = {51},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). An integer arithmetic-based AMG preconditioned FGMRES solver. <em>TOMS</em>, <em>51</em>(1), 1-25. (<a href='https://doi.org/10.1145/3704726'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We consider solving a sparse linear system using integer (fixed-point) arithmetic. Integer arithmetic has attracted attention in scientific computing because of its high computational efficiency. Furthermore, considering the current circumstances of hardware development, integer arithmetic is expected to become increasingly important. Nevertheless, integer arithmetic has not been widely used for solving linear systems because it lacks robustness against overflow and underflow, making it hard to solve practical problems. Thus, we propose a new integer-based implementation framework for the Flexible GMRES (FGMRES) method, which enables integer-based solvers to solve linear systems with the same accuracy as conventional floating-point solvers. In addition, we propose an integer-only algebraic multigrid preconditioner. Combining it with the integer-based FGMRES framework, we develop an integer-based solver. Numerical experiments on CPUs showed that the developed integer-based solver has a comparable convergence rate to floating-point solvers. We also found the test cases where the integer-based solver runs faster than the floating-point solvers.},
  archive      = {J_TOMS},
  author       = {Kengo Suzuki and Takeshi Fukaya and Takeshi Iwashita},
  doi          = {10.1145/3704726},
  journal      = {ACM Transactions on Mathematical Software},
  month        = {3},
  number       = {1},
  pages        = {1-25},
  shortjournal = {ACM Trans. Math. Softw.},
  title        = {An integer arithmetic-based AMG preconditioned FGMRES solver},
  volume       = {51},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Optimal approximation of the 1/ function using chebyshev polynomials and magic constants. <em>TOMS</em>, <em>51</em>(1), 1-38. (<a href='https://doi.org/10.1145/3708472'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this article we analyze low-cost accurate approximation of the function \(1/x\) using Chebyshev polynomials of the first kind and minimizing number of elementary operations in computer codes (in particular, by using the so-called magic constants). It is shown that Newton-Raphson iterative method is not optimal and a new approach is proposed. We prove that optimal Chebyshev polynomials can be factorized in terms of Chebyshev polynomials of lower order which leads to new optimal iteration schemes. We also construct a family of new algorithms by dividing the considered interval into sub-intervals where different magic constants and multiplicative factors are used (in order to increase the accuracy). Theoretical considerations and proofs are completed with numerical tests on three types of microcontroller processors.},
  archive      = {J_TOMS},
  author       = {Cezary J. Walczyk and Leonid V. Moroz and Volodymyr Samotyy and Jan L. Cieśliński},
  doi          = {10.1145/3708472},
  journal      = {ACM Transactions on Mathematical Software},
  month        = {3},
  number       = {1},
  pages        = {1-38},
  shortjournal = {ACM Trans. Math. Softw.},
  title        = {Optimal approximation of the 1/ function using chebyshev polynomials and magic constants},
  volume       = {51},
  year         = {2025},
}
</textarea>
</details></li>
</ul>

</body>
</html>
