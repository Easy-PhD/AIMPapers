<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>IANDC</title>
  <style>
    html {font-size: 22px;}
    body {margin: 0 auto; max-width: 76em;}
    #copyID {font-size: 18px;}
  </style>
  <script>
    function copy(element) {
      if (element.type == "button"){
      element.type="text";
      }
      element.style.color="black";
      element.style.backgroundColor="#C7EDCC";
      element.select();
      element.setSelectionRange(0, 99999);
      navigator.clipboard.writeText(element.value);
      window.getSelection().removeAllRanges();
      element.type="button";
    }
  </script>
</head>
<body>

<h2 id="iandc">IANDC - 82</h2>
<ul>
<li><details>
<summary>
(2025). Changing induced subgraph isomorphisms under extended reconfiguration rules. <em>IANDC</em>, <em>307</em>, 105367. (<a href='https://doi.org/10.1016/j.ic.2025.105367'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In a reconfiguration problem, we are given two feasible solutions of a combinatorial problem and our goal is to determine whether it is possible to reconfigure one into the other, with the steps dictated by specific reconfiguration rules. Traditionally, most studies on reconfiguration problems have focused on rules that allow changing a single element at a time. In contrast, this paper considers scenarios in which k ≥ 2 elements can be changed simultaneously. We investigate the general reconfiguration problem of isomorphisms. For the Induced Subgraph Isomorphism Reconfiguration problem, we show that the problem remains PSPACE -complete even under stringent constraints on the pattern graph when k is constant. We then give two meta-theorems applicable when k is slightly less than the number of vertices in the pattern graph. In addition, we investigate the complexity of the Independent Set Reconfiguration problem, which is a special case of the Induced Subgraph Isomorphism Reconfiguration problem.},
  archive      = {J_IANDC},
  author       = {Tatsuhiro Suga and Akira Suzuki and Yuma Tamura and Xiao Zhou},
  doi          = {10.1016/j.ic.2025.105367},
  journal      = {Information and Computation},
  month        = {11},
  pages        = {105367},
  shortjournal = {Inf. Comput.},
  title        = {Changing induced subgraph isomorphisms under extended reconfiguration rules},
  volume       = {307},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Hardness and approximability of bounded access lempel ziv coding. <em>IANDC</em>, <em>307</em>, 105366. (<a href='https://doi.org/10.1016/j.ic.2025.105366'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We study the complexity of constructing an optimal parsing φ of a string s = s 1 … s n under the constraint that given a position p in the original text, and the LZ76-like (Lempel Ziv 76) encoding of T based on φ , it is possible to identify/decompress the character s p by performing at most c accesses to the LZ encoding, for a given integer c . We refer to such a parsing φ as a c -bounded access LZ parsing or c -BLZ parsing of s . We show that for any constant c the problem of computing the optimal c -BLZ parsing of a string, i.e., the one with the minimum number of phrases, is NP -hard and also APX -hard, i.e., no P T A S can exist under the standard complexity assumption P ≠ N P . We also study the ratio between the sizes of an optimal c -BLZ parsing of a string s and an optimal LZ76 parsing of s (which can be greedily computed in polynomial time). For this we establish a non-trivial lower bound Ω ( | s | c + 1 ) on the size of an optimal parsing for a square free string s , and also show that such a lower bound is tight for a large class of (square free) morphic words. Finally, after showing that under ETH, every algorithm for c -BLZ requires time 2 Ω ( | s | 1 c ) , hence strongly exponential in the special case c = 1 , we show an algorithm matching this bound that can compute an optimal 1-BLZ parsing of a string s in time O ⁎ ( 1.755 | s | ) .},
  archive      = {J_IANDC},
  author       = {Ferdinando Cicalese and Francesca Ugazio},
  doi          = {10.1016/j.ic.2025.105366},
  journal      = {Information and Computation},
  month        = {11},
  pages        = {105366},
  shortjournal = {Inf. Comput.},
  title        = {Hardness and approximability of bounded access lempel ziv coding},
  volume       = {307},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). On the equivalence of uniform key agreement and sequential composition insecurity. <em>IANDC</em>, <em>307</em>, 105365. (<a href='https://doi.org/10.1016/j.ic.2025.105365'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {This work revisits the relationship between the existence of uniform transcript key agreements (UTKA) and the statement that the sequential composition of two general non-adaptively secure pseudorandom functions ( na PRFs) must be a pseudorandom function (PRF). Pietrzak (Crypto'06) showed that if the statement is false (i.e., there exists two na PRFs whose sequential composition is not a PRF), then a key agreement (KA) exists. This result is significant, since it reveals a surprising connection between a security property in symmetric-key cryptography and the existence of a public-key primitive. Later, Cho, Lee and Ostrovsky (Crypto'10) pointed out that the KA constructed by Pietrzak was in fact a UTKA, and established the equivalence between the existence of UTKAs and the falsification of the above statement. In particular, they proved the reverse direction of Pietrzak's result: if UTKAs exist, then a counterexample to sequential composition exists. Furthermore, Cho et al. also proved a similar equivalence of UTKA and parallel composition insecurity. Unfortunately, we found that Cho et al.'s counterexample to sequential composition from UTKAs was not correct, since the primitive functions in it were not actually na PRFs (more specifically, part of their output only depends on part of their input). Our view is that the failure may be inherent. In particular, we provide strong evidence that it is impossible to construct a counterexample to sequential composition from UTKAs.},
  archive      = {J_IANDC},
  author       = {Yusai Wu and Liqing Yu and Yu Yu},
  doi          = {10.1016/j.ic.2025.105365},
  journal      = {Information and Computation},
  month        = {11},
  pages        = {105365},
  shortjournal = {Inf. Comput.},
  title        = {On the equivalence of uniform key agreement and sequential composition insecurity},
  volume       = {307},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). The h-step limited star connectivity of hypercubes. <em>IANDC</em>, <em>307</em>, 105364. (<a href='https://doi.org/10.1016/j.ic.2025.105364'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Under the sense of isomorphism, a 0 -step star is K 1 , and a t-step star with t ≥ 1 is a rooted tree where every fork node has degree 2 and the distance between the root and every leaf is exactly t . For any integer h ≥ t , a t -step star is called an h-step limited star . Given a connected non-complete graph G and a non-negative integer h , let T be an h -step star with the root degree 0 if h = 0 and Δ ( G ) otherwise, and let F be a set of some h -step limited stars whose root degrees do not exceed the root degree of T . F is called an h-step limited star cut ( h- sls -cut , for short) of G if the removal of all the trees in F disconnects G . The h-step limited star connectivity of G , denoted by , is the minimum cardinality over all h - sls -cuts, if any, of G . The n -dimensional hypercube Q n is one of the most attractive inerconnection networks for parallel and distributed systems. In this short paper, we mainly prove that ( i ) for n ≥ 2 , and ( i i ) for n ≥ 3 , and ( i i i ) for n ≥ 3 and h ≥ 2 .},
  archive      = {J_IANDC},
  author       = {Yuxing Yang},
  doi          = {10.1016/j.ic.2025.105364},
  journal      = {Information and Computation},
  month        = {11},
  pages        = {105364},
  shortjournal = {Inf. Comput.},
  title        = {The h-step limited star connectivity of hypercubes},
  volume       = {307},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Cyclic operator precedence grammars for parallel parsing. <em>IANDC</em>, <em>307</em>, 105363. (<a href='https://doi.org/10.1016/j.ic.2025.105363'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Operator precedence languages (OPLs) enjoy the local parsability property, which means that a code fragment enclosed within a pair of markers playing the role of parentheses can be parsed with no knowledge of its external context. This property has been exploited to build parallel parsers for languages formalized as OPLs. It has been observed, however, that when the syntax trees of sentences have a linear substructure, parsing must necessarily proceed sequentially, making it ineffective to split such a subtree into chunks to be processed in parallel. This inconvenience derives from the hypothesis that the equality precedence relation cannot be cyclic, which has been so far assumed by most literature on OPLs. This hypothesis was motivated by the need to keep the mathematical notation as simple as possible, although it caused a discrepancy between the expressive power of operator precedence grammars and other formalisms defining OPLs such as operator precedence automata, monadic second order logic and operator precedence expressions, which do not assume acyclicity. We present an enriched version of operator precedence grammars, called cyclic , that allows for a simplified version of regular expressions in the right hand sides of grammar rules. For this class of operator precedence grammars the acyclicity hypothesis of the equality precedence relation is no more needed to guarantee the algebraic properties of the generated languages. The expressive power of the cyclic grammars is now fully equivalent to that of other formalisms defining OPLs. As a result, cyclic operator precedence grammars produce unranked syntax trees and sentences with flat unbounded substructures that can be naturally partitioned into chunks suitable for parallel parsing.},
  archive      = {J_IANDC},
  author       = {Michele Chiari and Dino Mandrioli and Matteo Pradella},
  doi          = {10.1016/j.ic.2025.105363},
  journal      = {Information and Computation},
  month        = {11},
  pages        = {105363},
  shortjournal = {Inf. Comput.},
  title        = {Cyclic operator precedence grammars for parallel parsing},
  volume       = {307},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Automating approximation analysis for nash equilibria algorithms in two-player games. <em>IANDC</em>, <em>307</em>, 105362. (<a href='https://doi.org/10.1016/j.ic.2025.105362'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Computing polynomial-time approximate Nash equilibria (NE) is a fundamental problem in algorithmic game theory, with deep connections to the complexity class TFNP. Recent advances in approximate NE algorithms have become increasingly sophisticated, making the verification of their approximation guarantees both complex and error-prone. We present the first automated method for analyzing approximation bounds of algorithms for two-player normal-form games. Given any algorithm that computes approximate NE, our approach automatically derives tight approximation bounds using constraint programming techniques. We demonstrate the effectiveness of our method by applying it to all known algorithms in the literature, reproducing their manually-proven approximation bounds within seconds and without human intervention. Our results provide both a powerful verification tool and new insights into the structure of approximate equilibrium computation.},
  archive      = {J_IANDC},
  author       = {Xiaotie Deng and Dongchen Li and Hanyu Li},
  doi          = {10.1016/j.ic.2025.105362},
  journal      = {Information and Computation},
  month        = {11},
  pages        = {105362},
  shortjournal = {Inf. Comput.},
  title        = {Automating approximation analysis for nash equilibria algorithms in two-player games},
  volume       = {307},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Unbounded quantum-classical separation in sample complexity for sphere center finding. <em>IANDC</em>, <em>307</em>, 105361. (<a href='https://doi.org/10.1016/j.ic.2025.105361'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Fast quantum algorithms can solve important computational problems more efficiently than classical algorithms. However, little is known about whether quantum computing can speed up solving geometric problems. This article explores quantum advantages for the problem of finding the center of a sphere in vector spaces over finite fields, given samples of random points on the sphere. We prove that any classical algorithm for this task requires approximately as many samples as the dimension of the vector space, by a reduction to an old and basic algebraic result—Warning's second theorem. On the other hand, we propose a quantum algorithm based on quantum walks that needs only a constant number of samples to find the center. Thus, an unbounded quantum advantage is revealed for a natural and intuitive geometric problem, which highlights the power of quantum computing in solving geometric problems.},
  archive      = {J_IANDC},
  author       = {Guanzhong Li and Lvzhou Li},
  doi          = {10.1016/j.ic.2025.105361},
  journal      = {Information and Computation},
  month        = {11},
  pages        = {105361},
  shortjournal = {Inf. Comput.},
  title        = {Unbounded quantum-classical separation in sample complexity for sphere center finding},
  volume       = {307},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Monotonicity characterizations of regular languages. <em>IANDC</em>, <em>307</em>, 105360. (<a href='https://doi.org/10.1016/j.ic.2025.105360'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Each language L ⊆ Σ ⁎ induces an infinite sequence { P r ( L , n ) } n = 1 ∞ , where for all n ≥ 1 , the value P r ( L , n ) ∈ [ 0 , 1 ] is the probability of a word of length n to be in L , assuming a uniform distribution on the letters in Σ. Previous studies of { P r ( L , n ) } n = 1 ∞ for a regular language L , concerned zero-one laws, density, and accumulation points. We study monotonicity of { P r ( L , n ) } n = 1 ∞ , possibly in the limit. We show that monotonicity may depend on the distribution of letters, study how operations on languages affect monotonicity, and characterize classes of languages for which the sequence is monotonic. We extend the study to languages L of infinite words, where we study the probability of lasso-shaped words to be in L and consider two definitions for P r ( L , n ) . The first refers to the probability of prefixes of length n to be extended to words in L , and the second to the probability of word w of length n to be such that w ω is in L . Thus, in the second definition, monotonicity depends not only on the length of w , but also on the words being periodic. We also study the complexity of calculating P r ( L , n ) for the various definitions.},
  archive      = {J_IANDC},
  author       = {Yoav Feinstein and Orna Kupferman},
  doi          = {10.1016/j.ic.2025.105360},
  journal      = {Information and Computation},
  month        = {11},
  pages        = {105360},
  shortjournal = {Inf. Comput.},
  title        = {Monotonicity characterizations of regular languages},
  volume       = {307},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Assumptions of randomness in cosmology models. <em>IANDC</em>, <em>307</em>, 105359. (<a href='https://doi.org/10.1016/j.ic.2025.105359'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Non-compact symmetries cannot be fully broken by randomness since non-compact groups have no invariant probability distributions. In particular, this makes trickier the “Copernican” random choice of the place of the observer in infinite cosmology models. This problem may be circumvented with what topologists call pointed spaces . Then randomness will be used only in building (infinite) models around the pre-designated “observance point”, that thus would not need to be randomly chosen. Additional complications come from the original randomness possibly being hidden. P. Gacs and A. Kucera proved that every sequence can be algorithmically generated from a random one. But Vladimir V'yugin discovered that randomized algorithms can with positive probability generate uncomputable sequences not algorithmically equivalent to any random ones.},
  archive      = {J_IANDC},
  author       = {Leonid A. Levin},
  doi          = {10.1016/j.ic.2025.105359},
  journal      = {Information and Computation},
  month        = {11},
  pages        = {105359},
  shortjournal = {Inf. Comput.},
  title        = {Assumptions of randomness in cosmology models},
  volume       = {307},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Intersection and union hierarchies of deterministic context-free languages and pumping lemmas. <em>IANDC</em>, <em>307</em>, 105358. (<a href='https://doi.org/10.1016/j.ic.2025.105358'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We study the computational complexity of finite intersections and finite unions of deterministic context-free (dcf) languages. Earlier, Wotschke [J. Comput. System Sci. 16 (1978) 456–461] demonstrated that intersections of ( d + 1 ) dcf languages are in general more powerful than intersections of d dcf languages for any positive integer d based on the separation result of the intersection hierarchy of Liu and Weiner [Math. Systems Theory 7 (1973) 185–192]. The argument of Liu and Weiner, however, works only on bounded languages of particular forms, and therefore Wotschke's result is not directly extendable to other non-bounded languages. To deal with a wide range of languages for the non-membership to the intersection hierarchy, we circumvent the specialization of their proof technics and devise a new and practical technical tool: two pumping lemmas for finite unions of dcf languages. Since the family of dcf languages is closed under complementation and also under intersection with regular languages, these pumping lemmas help us establish the non-membership relation of languages formed by finite intersections of target languages. We also concern ourselves with a relationship to deterministic limited automata of Hibbard [Inf. Control 11 (1967) 196–238] in this regard.},
  archive      = {J_IANDC},
  author       = {Tomoyuki Yamakami},
  doi          = {10.1016/j.ic.2025.105358},
  journal      = {Information and Computation},
  month        = {11},
  pages        = {105358},
  shortjournal = {Inf. Comput.},
  title        = {Intersection and union hierarchies of deterministic context-free languages and pumping lemmas},
  volume       = {307},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). K-universality of regular languages. <em>IANDC</em>, <em>307</em>, 105357. (<a href='https://doi.org/10.1016/j.ic.2025.105357'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A subsequence of a word w is a word u such that u = w [ i 1 ] w [ i 2 ] … w [ i k ] , for some set of indices 1 ≤ i 1 < i 2 < … < i k ≤ | w | . A word w is k -subsequence universal over an alphabet Σ if every word in Σ k appears in w as a subsequence. In this paper, we study the intersection between the set of k -subsequence universal words over some alphabet Σ and regular languages over Σ. We call a regular language L k- ∃ -subsequence universal if there exists a k -subsequence universal word in L , and k- ∀ -subsequence universal if every word of L is k -subsequence universal. We give algorithms solving the problems of deciding if a given regular language, represented by a finite automaton recognising it, is k- ∃ -subsequence universal and, respectively, if it is k- ∀ -subsequence universal , for a given k . The algorithms are FPT w.r.t. the size of the input alphabet, and their run-time does not depend on k ; they run in polynomial time in the number n of states of the input automaton when the size of the input alphabet is O ( log ⁡ n ) . Moreover, we show that the problem of deciding if a given regular language is k- ∃ -subsequence universal is NP-complete, when the language is over a large alphabet. Further, we provide algorithms for counting the number of k -subsequence universal words (paths) accepted by a given deterministic (respectively, non-deterministic) finite automaton, and ranking an input word (path) within the set of k -subsequence universal words accepted by a given finite automaton.},
  archive      = {J_IANDC},
  author       = {Duncan Adamson and Pamela Fleischmann and Annika Huch and Tore Koß and Florin Manea and Dirk Nowotka},
  doi          = {10.1016/j.ic.2025.105357},
  journal      = {Information and Computation},
  month        = {11},
  pages        = {105357},
  shortjournal = {Inf. Comput.},
  title        = {K-universality of regular languages},
  volume       = {307},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Recent algorithmic advances in simple temporal networks with uncertainty: From faster controllability checking to faster execution. <em>IANDC</em>, <em>307</em>, 105356. (<a href='https://doi.org/10.1016/j.ic.2025.105356'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {This paper advances the state of the art in the dynamic controllability (DC) and dispatchability of Simple Temporal Networks with Uncertainty (STNUs) through four key contributions. First, findSRNC is an algorithm that identifies semi-reducible negative cycles in non-dynamically controllable STNUs. Running in O ( m n + k 2 n + k n log ⁡ n ) time (matching the fastest DC-checking algorithms), it handles repeated edges and uses polynomial space, even when cycles might contain exponentially many edges. Second, minDisp ESTNU + is an algorithm that improves dispatchability computation for STNUs from O ( k n 3 ) to O ( n 3 + k 2 n log ⁡ n ) time. It outputs dispatchable Extended STNUs (ESTNUs) having minimal numbers of edges, which is crucial for subsequent real-time execution. Third, the Canonical Form of Nested Diamond Structures in Dispatchable ESTNUs is a rigorous theory that facilitates correctness proofs for dispatchability algorithms. It also helped reveal and correct a flaw in a previously published algorithm. Fourth, our empirical evaluation using improved open-source implementations demonstrates the practical effectiveness of our algorithms. These contributions address fundamental computational bottlenecks in temporal planning systems, enabling more efficient reasoning about uncertain timing constraints while providing real-time guarantees required for robotics, scheduling, and automated planning applications.},
  archive      = {J_IANDC},
  author       = {Luke Hunsberger and Roberto Posenato},
  doi          = {10.1016/j.ic.2025.105356},
  journal      = {Information and Computation},
  month        = {11},
  pages        = {105356},
  shortjournal = {Inf. Comput.},
  title        = {Recent algorithmic advances in simple temporal networks with uncertainty: From faster controllability checking to faster execution},
  volume       = {307},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Polynomial turing compressions for some graph problems parameterized by modular-width. <em>IANDC</em>, <em>307</em>, 105355. (<a href='https://doi.org/10.1016/j.ic.2025.105355'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A polynomial Turing compression (PTC) for a parameterized problem L is a polynomial time Turing machine that has access to an oracle for a problem L ′ such that a polynomial in the input parameter bounds each query. Meanwhile, a polynomial compression (PC) can be regarded as a restricted variant of PTC where the machine can query the oracle exactly once and must output the same answer as the oracle. Bodlaender et al. (ICALP 2008) and Fortnow and Santhanam (STOC 2008) initiated an impressive hardness theory for PC under the assumption coNP ⊈ NP/poly. Let C be the set of all problems with PTCs but without PCs assuming coNP ⊈ NP/poly. Fernau et al. (STACS 2009) identified Leaf Out-tree( k ) as the first problem in C . However, little is known about C , with only a dozen problems confirmed in it over the last fifteen years. Open questions remain, such as whether CNF-SAT( n ) and k -path are in C , requiring novel ideas to clarify the differences between PTCs and PCs. In this paper, we enrich our knowledge about C by demonstrating that 17 problems parameterized by modular-width ( mw ), such as Chromatic Number( mw ) and Hamiltonian Cycle( mw ) , belong to C . Additionally, we develop a general recipe to prove the existence of PTCs for a class of problems, including these 17.},
  archive      = {J_IANDC},
  author       = {Weidong Luo},
  doi          = {10.1016/j.ic.2025.105355},
  journal      = {Information and Computation},
  month        = {11},
  pages        = {105355},
  shortjournal = {Inf. Comput.},
  title        = {Polynomial turing compressions for some graph problems parameterized by modular-width},
  volume       = {307},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). On cardinalities of rogers semilattices for families in the ershov hierarchy. <em>IANDC</em>, <em>307</em>, 105354. (<a href='https://doi.org/10.1016/j.ic.2025.105354'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The theory of numberings provides classification results for families of sets in various computability-theoretic hierarchies. The algorithmic content of numberings is typically calibrated via the reducibility between numberings. For a given family of sets S , this reducibility gives rise to an upper semilattice of degrees that is often called the Rogers semilattice of S . This paper studies the cardinalities of Rogers semilattices for families of sets at finite levels of the Ershov hierarchy. The classical result of Khutoretskii (1971) shows that the Rogers semilattice of a family of c.e. sets is either one-element or countably infinite. Badaev and Lempp (2009) constructed a family of d.c.e. sets that demonstrates that the methods of Khutoretskii cannot be applied to obtain a similar result for Rogers semilattices already at the second level of the Ershov hierarchy. We prove that for any finite family of sets S at any finite level of the Ershov hierarchy, the corresponding Rogers semilattice is either one-element or countably infinite. We also obtain another sufficient condition for a Rogers semilattice to be infinite. This condition implies that the Rogers semilattice of Badaev and Lempp is also infinite.},
  archive      = {J_IANDC},
  author       = {Keng Meng Ng and Nikolay Bazhenov and Birzhan Kalmurzayev and Dias Nurlanbek},
  doi          = {10.1016/j.ic.2025.105354},
  journal      = {Information and Computation},
  month        = {11},
  pages        = {105354},
  shortjournal = {Inf. Comput.},
  title        = {On cardinalities of rogers semilattices for families in the ershov hierarchy},
  volume       = {307},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Exact counting of subtrees with diameter no more than d in trees: A generating function approach. <em>IANDC</em>, <em>307</em>, 105353. (<a href='https://doi.org/10.1016/j.ic.2025.105353'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Network motifs, regarded as fundamental building blocks, offer crucial insights into the structure and function of complex networks, with broad applications across disciplines including sociology, computer science, bioinformatics, chemoinformatics, and pharmaceutics. However, the identification of network motifs remains a significant and computationally challenging problem. Among various motifs, subtree enumeration has garnered substantial attention in recent years, particularly due to its relevance in network science and bioinformatics. For an n -vertex tree T , by introducing novel generating functions with ( d + 2 ) variables, we propose an innovative algorithm for the exact enumeration of T 's subtrees rooted at fixed vertex v , where the distance between v and the farthest leaf is k = 0 , 1 , … , d , and the distance between any two leaves is no more than d . Building on this algorithm, we develop novel recursive algorithms for exact enumerating various diameter no more than d subtrees (abbreviated as DNMT- d subtrees) of T . As applications, we apply these algorithms to derive the number of DNMT- d subtrees in a full binary tree B h with h ≥ 2 levels, and briefly discuss the density of DNMT- d subtrees in general trees. Our research generalizes the work of Frank Ruskey on Listing and Counting Subtrees of a Tree in 1981 and makes it a special case of our study where d equals the diameter of the tree T . Moreover, the proposed O ( d n 2 ) algorithms introduce new approaches for enumerating subtrees under diameter constraints and lay the groundwork for counting diameter-constrained subgraphs (motifs) in complex networks.},
  archive      = {J_IANDC},
  author       = {Yu Yang and Bang-Bang Jin and Xiaoming Sun and Xiao-Dong Zhang and Bo Li and Kai Zhao and Hua Wang},
  doi          = {10.1016/j.ic.2025.105353},
  journal      = {Information and Computation},
  month        = {11},
  pages        = {105353},
  shortjournal = {Inf. Comput.},
  title        = {Exact counting of subtrees with diameter no more than d in trees: A generating function approach},
  volume       = {307},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Decision problems for systems of language equations and inequations. <em>IANDC</em>, <em>307</em>, 105344. (<a href='https://doi.org/10.1016/j.ic.2025.105344'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Systems of language equations φ ( X 1 , … , X n ) = ψ ( X 1 , … , X n ) and inequations φ ( X 1 , … , X n ) ≠ ψ ( X 1 , … , X n ) are studied, where φ and ψ may contain Boolean operations and concatenation. It is proved that the problem whether such a system has a solution is Σ 2 0 -complete in the arithmetical hierarchy (cf. the earlier studied case of equations only, where it is co-r.e.-complete), the problem whether it has a unique solution is in Σ 3 0 ∩ Π 3 0 , and is both Σ 2 0 -hard and Π 2 0 -hard, existence of a finite or regular solution is an r.e.-complete problem, while testing whether a system has finitely many solutions is Σ 3 0 -complete. Furthermore, it is shown that the class of languages representable by unique solutions of such systems is exactly the class of recursive sets, but decision procedures for the set cannot be algorithmically constructed out of a system. All results hold already for equations over a unary alphabet.},
  archive      = {J_IANDC},
  author       = {Alexander Okhotin},
  doi          = {10.1016/j.ic.2025.105344},
  journal      = {Information and Computation},
  month        = {11},
  pages        = {105344},
  shortjournal = {Inf. Comput.},
  title        = {Decision problems for systems of language equations and inequations},
  volume       = {307},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Towards a theoretical understanding of why local search works for clustering with fair-center representation. <em>IANDC</em>, <em>307</em>, 105343. (<a href='https://doi.org/10.1016/j.ic.2025.105343'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The representative k -median problem generalizes the classical clustering formulations in that it partitions the data points into ℓ disjoint demographic groups and imposes a lower-bound constraint on the number of opened facilities from each group, such that all the groups are fairly represented by the opened facilities. Due to its simplicity, the local-search heuristic, which iteratively swaps a bounded number of closed facilities for the same number of opened ones to improve the solution, has been frequently used in the representative k -median problem. It is known that the local-search heuristic, when restricted to constant-size swaps, yields a constant-factor approximation if ℓ = 2 , and has an unbounded approximation ratio if ℓ is super-constant. However, for any constant ℓ > 2 , the existence of a constant-factor approximation under constant-size swaps remained an open question for a long time. In response to this question, we demonstrate that the local-search heuristic guarantees a ( 4 ℓ + 5 ) -approximation when up to ℓ ( ℓ + 1 ) facilities are allowed to be swapped in each iteration, thus providing an affirmative answer to the question. Our main technical contribution is a novel approach for theoretically analyzing the local-search heuristic, which bounds its approximation ratio by linearly combining the clustering cost increases induced by a set of hierarchically organized swaps. Our techniques also generalize to the k -means clustering formulation and reveal similar approximation guarantees for the local-search heuristic.},
  archive      = {J_IANDC},
  author       = {Zhen Zhang and Junfeng Yang and Limei Liu and Xuesong Xu and Guozhen Rong and Qilong Feng},
  doi          = {10.1016/j.ic.2025.105343},
  journal      = {Information and Computation},
  month        = {11},
  pages        = {105343},
  shortjournal = {Inf. Comput.},
  title        = {Towards a theoretical understanding of why local search works for clustering with fair-center representation},
  volume       = {307},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). The billaud conjecture for alphabet size 4. <em>IANDC</em>, <em>307</em>, 105342. (<a href='https://doi.org/10.1016/j.ic.2025.105342'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The Billaud Conjecture, first stated in 1993, is a fundamental problem on finite words and their heirs, i.e., the words obtained by a projection deleting a single letter. The conjecture states that every morphically primitive word, i.e., a word that is not a fixed point of any non-identity morphism, has at least one morphically primitive heir. The correctness of the conjecture has so far been established in a few special cases, which mainly restrict the alphabet size. In this paper we give a proof for the next such case, i.e., for alphabet size 4.},
  archive      = {J_IANDC},
  author       = {Szymon Łopaciuk and Daniel Reidenbach},
  doi          = {10.1016/j.ic.2025.105342},
  journal      = {Information and Computation},
  month        = {11},
  pages        = {105342},
  shortjournal = {Inf. Comput.},
  title        = {The billaud conjecture for alphabet size 4},
  volume       = {307},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). The g-good-neighbor diagnosability of product networks under the PMC model. <em>IANDC</em>, <em>307</em>, 105341. (<a href='https://doi.org/10.1016/j.ic.2025.105341'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The concept of neighbor connectivity originated from the assessment of the subversion of espionage networks caused by underground resistance movements, and it has now been applied to measure the disruption of networks caused by cascading failures through neighbors. In this paper, we give two necessary and sufficient conditions of the existence of g -good-neighbor diagnosability. We introduce a new concept called g -good neighbor cut-component number (gc number for short), which has close relation with g -good-neighbor diagnosability. Sharp lower and upper bounds of the gc number of general graphs in terms of the g -good neighbor connectivity have been proposed, which provide a formula to compute the g -good-neighbor diagnosability for general graphs (therefore for Cartesian product graphs). As their applications, we get the exact values or bounds for the gc numbers and g -good-neighbor diagnosability of grid, torus networks and generalized cubes.},
  archive      = {J_IANDC},
  author       = {Zhao Wang and Yaping Mao and Sun-Yuan Hsieh and Ralf Klasing},
  doi          = {10.1016/j.ic.2025.105341},
  journal      = {Information and Computation},
  month        = {11},
  pages        = {105341},
  shortjournal = {Inf. Comput.},
  title        = {The g-good-neighbor diagnosability of product networks under the PMC model},
  volume       = {307},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Two-state spin systems with negative interactions. <em>IANDC</em>, <em>307</em>, 105340. (<a href='https://doi.org/10.1016/j.ic.2025.105340'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We study the approximability of computing the partition functions of two-state spin systems. The problem is parameterized by a 2 × 2 symmetric matrix. Previous results on this problem were restricted either to the case where the matrix has non-negative entries, or to the case where the diagonal entries are equal, i.e. Ising models. In this paper, we study the generalization to arbitrary 2 × 2 interaction matrices with real entries. We show that in some regions of the parameter space, it's #P-hard to even determine the sign of the partition function, while in other regions there are fully polynomial approximation schemes for the partition function. Our results reveal several new computational phase transitions.},
  archive      = {J_IANDC},
  author       = {Yumou Fei and Leslie Ann Goldberg and Pinyan Lu},
  doi          = {10.1016/j.ic.2025.105340},
  journal      = {Information and Computation},
  month        = {11},
  pages        = {105340},
  shortjournal = {Inf. Comput.},
  title        = {Two-state spin systems with negative interactions},
  volume       = {307},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Competition among parallel contests. <em>IANDC</em>, <em>307</em>, 105339. (<a href='https://doi.org/10.1016/j.ic.2025.105339'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We investigate the model of multiple rank-order contests held in parallel, where each contestant only selects one contest to join and each contest designer decides the prize structure to compete for the participation of contestants. We first analyze the strategic behaviors of contestants and completely characterize the symmetric Bayesian Nash equilibrium. As for the strategies of contest designers, when other designers' strategies are known, we show that computing the best response is NP-hard and propose a fully polynomial time approximation scheme to output the ϵ -approximate best response. When other designers' strategies are unknown, we provide a worst-case analysis on one designer's strategy. We give an upper bound on the worst-case utility of any strategy and propose a method to construct a strategy whose utility can guarantee a constant ratio of this upper bound in the worst case.},
  archive      = {J_IANDC},
  author       = {Xiaotie Deng and Ningyuan Li and Weian Li and Qi Qi},
  doi          = {10.1016/j.ic.2025.105339},
  journal      = {Information and Computation},
  month        = {11},
  pages        = {105339},
  shortjournal = {Inf. Comput.},
  title        = {Competition among parallel contests},
  volume       = {307},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Concept analysis approach for graphs. <em>IANDC</em>, <em>306</em>, 105338. (<a href='https://doi.org/10.1016/j.ic.2025.105338'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Graphs possess the ability to model complex systems in the real world, leading to their widespread application in fields such as social network analysis and recommendation systems. However, one of the major challenges in processing graph data lies in the inherent structural complexity of graphs. Consequently, extracting meaningful structural information from graph data has become a significant area of research. Formal Concept Analysis provides a method for expressing and analyzing algebraic structures by constructing concept lattices, which can effectively uncover complex structures within data. This paper proposes a concept analysis approach for graph data, revealing the relationship between graph structures and their corresponding concepts. Initially, the paper focuses on the connected components of disconnected graphs, exploring their specific representations in their respective concept lattices, and demonstrating that each connected component corresponds to a connected equivalence class within its associated lattice. Subsequently, the paper investigates the correspondence between graph structures of connected components and their associated concepts, identifying the concepts corresponding to cliques and to non-clique connected subgraphs. The findings indicate that these graph structures can be reconstructed through their corresponding concepts, thereby transforming operations on graph structures into operations on concepts and offering a novel perspective on graph structure manipulation. Finally, the paper analyzes the correspondence between concepts in concept lattices and graph structures, revealing the rationale behind concept construction. The results show that the concepts are closely related to a special class of graph structures, namely maximal star-clique graphs.},
  archive      = {J_IANDC},
  author       = {Mengyao Zhao and Yanhui Zhai and Deyu Li},
  doi          = {10.1016/j.ic.2025.105338},
  journal      = {Information and Computation},
  month        = {9},
  pages        = {105338},
  shortjournal = {Inf. Comput.},
  title        = {Concept analysis approach for graphs},
  volume       = {306},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Existential and universal width of alternating finite automata. <em>IANDC</em>, <em>306</em>, 105337. (<a href='https://doi.org/10.1016/j.ic.2025.105337'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The existential width of an alternating finite automaton (AFA) A on a string w is, roughly speaking, the number of nondeterministic choices that A uses in an accepting computation on w that uses least nondeterminism. The universal width of A on string w is the least number of parallel branches an accepting computation of A on w needs to have. The existential or universal width of A is said to be finite if it is bounded for all accepted strings. We show that finiteness of existential and universal width of an AFA is decidable and at least PSPACE-hard. We consider the problem of deciding whether the existential or universal width is bounded by a given integer. We show that the problem is PSPACE-complete for AFAs where the number of transitions defined for a given universal state and input symbol is bounded by a constant.},
  archive      = {J_IANDC},
  author       = {Yo-Sub Han and Sungmin Kim and Sang-Ki Ko and Kai Salomaa},
  doi          = {10.1016/j.ic.2025.105337},
  journal      = {Information and Computation},
  month        = {9},
  pages        = {105337},
  shortjournal = {Inf. Comput.},
  title        = {Existential and universal width of alternating finite automata},
  volume       = {306},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Complexity of exclusive nondeterministic finite automata. <em>IANDC</em>, <em>306</em>, 105336. (<a href='https://doi.org/10.1016/j.ic.2025.105336'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Exclusive nondeterministic finite automata (XNFA) are nondeterministic finite automata with an exclusive-or-like acceptance condition. An input is accepted if there is exactly one accepting path in its computation tree. If there are none or more than one accepting paths, the input is rejected. It turns out that, from a descriptional complexity point of view, XNFAs differ significantly from the known types of finite automata. In particular the state costs for the simulation of an XNFA by a DFA are 3 n − 2 n + 1 states, while the costs for simulating an XNFA by an NFA are n ⋅ 2 n − 1 states. Both bounds are also shown to be tight. On the other hand, NFAs may have advantages in comparison to XNFAs. For the simulation of an NFA by an XNFA, a tight bound of 2 n − 1 states is given. Finally, we investigate the computational complexity of different decision problems for XNFAs and it turns out that emptiness, universality, inclusion, and equivalence are PSPACE -complete.},
  archive      = {J_IANDC},
  author       = {Martin Kutrib and Andreas Malcher and Matthias Wendlandt},
  doi          = {10.1016/j.ic.2025.105336},
  journal      = {Information and Computation},
  month        = {9},
  pages        = {105336},
  shortjournal = {Inf. Comput.},
  title        = {Complexity of exclusive nondeterministic finite automata},
  volume       = {306},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). SENDAI: A framework for joint reasoning about sensor data acquisition and sensor data analytics. <em>IANDC</em>, <em>306</em>, 105335. (<a href='https://doi.org/10.1016/j.ic.2025.105335'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Sensors are increasingly being deployed to monitor critical infrastructure. However, as the number of sensors being deployed increases, so does the amount of sensor data that must be transmitted, stored, and analyzed. Thus, a significant number of methods have been proposed to improve sensor data acquisition and analytics. However, the proposed strategies and methods generally focus exclusively on either sensor data acquisition or analytics, thus ignoring the possible optimization that can be performed by taking a holistic view. To explore this opportunity, this paper provides an overview of sensor data acquisition and analytics and an analysis of two very different use cases, specifically monitoring wind turbines and measuring utility consumption using smart meters. Based on this analysis, the Framework for joint Sensory Data Acquisition and Analytics (SENDAI) is proposed, an integrated framework that models sensor data acquisition and analytics together, thus enabling holistic reasoning about sensor data acquisition and analytics. To demonstrate how the information in SENDAI can be used to reason about sensor data acquisition and analytics together, we show how sensor data acquisition can be optimized to respond efficiently to query workloads.},
  archive      = {J_IANDC},
  author       = {Søren Kejser Jensen and Josefine Kejser and Federico Chiariotti and Christian Thomsen and Anders Ellersgaard Kalør and Petar Popovski and Beatriz Soret and Torben Bach Pedersen},
  doi          = {10.1016/j.ic.2025.105335},
  journal      = {Information and Computation},
  month        = {9},
  pages        = {105335},
  shortjournal = {Inf. Comput.},
  title        = {SENDAI: A framework for joint reasoning about sensor data acquisition and sensor data analytics},
  volume       = {306},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Linear-time safe-alternating DFS and SCCs. <em>IANDC</em>, <em>306</em>, 105334. (<a href='https://doi.org/10.1016/j.ic.2025.105334'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {An alternating graph is a directed graph whose vertex set is partitioned into two colour classes, existential and universal. This forms the basic arena for well-known models in formal verification, discrete optimal control, and infinite duration two-player games where Player □ and Player ○ alternate in a turn-based sliding of a pebble along the arcs they control. We study alternating strongly-connectedness on alternating graphs as a generalization of strongly-connectedness in directed graphs, aiming at providing a linear-time decomposition and a sound structural graph characterization. For this a novel notion of alternating reachability is introduced: Player □ attempts to reach vertices without leaving a prescribed subset of the vertices while Player ○ works against. This is named safe-alternating reachability . It is shown that every alternating graph uniquely decomposes into safe-alternating strongly-connected components , where Player □ can visit each vertex within a given component infinitely often without having to ever leave out the component itself. Our main result is a linear-time algorithm for computing this alternating graph decomposition. Both the underlying graph structures and the algorithm generalize the classical decomposition of a directed graph into strongly-connected components, building on the algorithms devised by Tarjan in 1972. Our theory has direct applications e.g. solving well-known infinite duration pebble games faster. Dinneen and Khoussainov showed in 1999 that deciding a given Update Game costs O ( m n ) time, where n is the number of vertices and m is that of arcs. We solve that task in Θ ( m + n ) linear time. In turn the complexity of Explicit McNaughton-Müller Games improves from cubic to quadratic.},
  archive      = {J_IANDC},
  author       = {Carlo Comin and Romeo Rizzi},
  doi          = {10.1016/j.ic.2025.105334},
  journal      = {Information and Computation},
  month        = {9},
  pages        = {105334},
  shortjournal = {Inf. Comput.},
  title        = {Linear-time safe-alternating DFS and SCCs},
  volume       = {306},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Relations between equation automata and follow automata. <em>IANDC</em>, <em>306</em>, 105333. (<a href='https://doi.org/10.1016/j.ic.2025.105333'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {This paper focuses on the relations between two small automata, i.e., the equation automaton and the follow automaton, which are both quotients of the position automaton. Ilie and Yu had pointed out that a rigorous analysis of their relations is necessary but difficult. We aim to tackle this problem. We first provide a sufficient condition for the equation automaton to be a quotient of the follow automaton, and then show that there exist different conditions under which the relations between these two automata vary.},
  archive      = {J_IANDC},
  author       = {Ping Lu and Haiming Chen},
  doi          = {10.1016/j.ic.2025.105333},
  journal      = {Information and Computation},
  month        = {9},
  pages        = {105333},
  shortjournal = {Inf. Comput.},
  title        = {Relations between equation automata and follow automata},
  volume       = {306},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Complexity of round-robin allocation with potentially noisy queries. <em>IANDC</em>, <em>306</em>, 105332. (<a href='https://doi.org/10.1016/j.ic.2025.105332'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We study the complexity of a fundamental algorithm for fairly allocating indivisible items, the round-robin algorithm. For n agents and m items, we show that the algorithm can be implemented in time O ( n m log ⁡ ( m / n ) ) in the worst case. If the agents' preferences are uniformly random, we establish an improved (expected) running time of O ( n m + m log ⁡ m ) . On the other hand, assuming comparison queries between items, we prove that Ω ( n m + m log ⁡ m ) queries are necessary to implement the algorithm, even when randomization is allowed. We also derive bounds in noise models where the answers to queries are incorrect with some probability. Our proofs involve novel applications of tools from multi-armed bandits, information theory, as well as posets and linear extensions.},
  archive      = {J_IANDC},
  author       = {Zihan Li and Pasin Manurangsi and Jonathan Scarlett and Warut Suksompong},
  doi          = {10.1016/j.ic.2025.105332},
  journal      = {Information and Computation},
  month        = {9},
  pages        = {105332},
  shortjournal = {Inf. Comput.},
  title        = {Complexity of round-robin allocation with potentially noisy queries},
  volume       = {306},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Special issue on 10th international workshop weighted automata: Theory and applications (WATA 2020). <em>IANDC</em>, <em>306</em>, 105331. (<a href='https://doi.org/10.1016/j.ic.2025.105331'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  archive      = {J_IANDC},
  author       = {Manfred Droste and Paul Gastin and Benjamin Monmege},
  doi          = {10.1016/j.ic.2025.105331},
  journal      = {Information and Computation},
  month        = {9},
  pages        = {105331},
  shortjournal = {Inf. Comput.},
  title        = {Special issue on 10th international workshop weighted automata: Theory and applications (WATA 2020)},
  volume       = {306},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Rauzy complexity and block entropy. <em>IANDC</em>, <em>306</em>, 105330. (<a href='https://doi.org/10.1016/j.ic.2025.105330'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In 1976, Rauzy studied two complexity functions, β _ and β ‾ , for infinite sequences over a finite alphabet. The function β _ achieves its maximum precisely for Borel normal sequences, while β ‾ reaches its minimum for sequences that, when added to any Borel normal sequence, result in another Borel normal sequence. We establish a connection between Rauzy's complexity functions, β _ and β ‾ , and the notions of non-aligned block entropy, h _ and h ‾ , by providing sharp upper and lower bounds for h _ in terms of β _ , and sharp upper and lower bounds for h ‾ in terms of β ‾ . We adopt a probabilistic approach by considering an infinite sequence of random variables over a finite alphabet. The proof relies on a new characterization of non-aligned block entropies, h ‾ and h _ , in terms of Shannon's conditional entropy. The bounds imply that sequences with h ‾ = 0 coincide with those for which β ‾ = 0 . We also show that the non-aligned block entropies, h _ and h ‾ , are essentially subadditive.},
  archive      = {J_IANDC},
  author       = {Verónica Becher and Olivier Carton and Santiago Figueira},
  doi          = {10.1016/j.ic.2025.105330},
  journal      = {Information and Computation},
  month        = {9},
  pages        = {105330},
  shortjournal = {Inf. Comput.},
  title        = {Rauzy complexity and block entropy},
  volume       = {306},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Pushdown and one-counter automata: Constant and non-constant memory usage. <em>IANDC</em>, <em>306</em>, 105329. (<a href='https://doi.org/10.1016/j.ic.2025.105329'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {It cannot be decided whether a one-counter automaton accepts each string in its language using a counter whose value is bounded, with respect to the length of the input, by a constant. Furthermore, when the counter is bounded by a constant, its value cannot be limited by any recursive function in the size of the machine. By taking into account the costs of all computations ( strong measure) or of all accepting computations ( accept measure) instead of those of the least expensive accepting computations ( weak measure), the above-mentioned problem becomes decidable for both pushdown automata and one-counter automata, while the bounds for the pushdown height or the value of the counter, when non constant, are recursive in the size of the machine. We also prove that, under the weak measure, if a one-counter automaton accepts with a counter that, with respect to the input length, is not bounded by any constants, then the counter grows at least as a logarithmic function. This is in contrast with the case of pushdown automata in which the bound is a double-logarithmic function. For the strong and accept measures these bounds are shown to be linear, for both pushdown and one-counter automata.},
  archive      = {J_IANDC},
  author       = {Giovanni Pighizzini and Luca Prigioniero},
  doi          = {10.1016/j.ic.2025.105329},
  journal      = {Information and Computation},
  month        = {9},
  pages        = {105329},
  shortjournal = {Inf. Comput.},
  title        = {Pushdown and one-counter automata: Constant and non-constant memory usage},
  volume       = {306},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Randomness and imprecision: From supermartingales to randomness tests. <em>IANDC</em>, <em>306</em>, 105328. (<a href='https://doi.org/10.1016/j.ic.2025.105328'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We generalise the randomness test definitions in the literature for both the Martin-Löf and Schnorr randomness of a series of binary outcomes, in order to allow for interval-valued rather than merely precise forecasts for these outcomes, and prove that under some computability conditions on the forecasts, our definition of Martin-Löf test randomness is related to Levin's uniform randomness. We also show that these new randomness notions are, under some computability and non-degeneracy conditions on the forecasts, equivalent to the martingale-theoretic versions we introduced in earlier papers. In addition, we prove that our generalised notion of Martin-Löf randomness can be characterised by universal supermartingales and universal randomness tests.},
  archive      = {J_IANDC},
  author       = {Gert de Cooman and Floris Persiau and Jasper De Bock},
  doi          = {10.1016/j.ic.2025.105328},
  journal      = {Information and Computation},
  month        = {9},
  pages        = {105328},
  shortjournal = {Inf. Comput.},
  title        = {Randomness and imprecision: From supermartingales to randomness tests},
  volume       = {306},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Computable one-way functions on the reals. <em>IANDC</em>, <em>306</em>, 105327. (<a href='https://doi.org/10.1016/j.ic.2025.105327'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A major open problem in computational complexity is the existence of a one-way function, namely a function from strings to strings which is computationally easy to compute but hard to invert. Levin (2023) formulated the notion of one-way functions from reals (infinite bit-sequences) to reals in terms of computability, and asked whether partial computable one-way functions exist. We give a strong positive answer using the hardness of the halting problem and exhibiting a total computable one-way function.},
  archive      = {J_IANDC},
  author       = {George Barmpalias and Xiaoyan Zhang},
  doi          = {10.1016/j.ic.2025.105327},
  journal      = {Information and Computation},
  month        = {9},
  pages        = {105327},
  shortjournal = {Inf. Comput.},
  title        = {Computable one-way functions on the reals},
  volume       = {306},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). On algorithms based on finitely many homomorphism counts. <em>IANDC</em>, <em>306</em>, 105326. (<a href='https://doi.org/10.1016/j.ic.2025.105326'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {It is a well-known result of Lovász that up to isomorphism a graph G is determined by the homomorphism counts hom ( F , G ) , i.e., the number of homomorphisms from F to G , where F ranges over all graphs. Thus, in principle, we can answer any query concerning G with only accessing the hom ( ⋅ , G ) 's instead of G itself. In this paper, we deal with queries φ for which there is a hom algorithm , i.e., there are finitely many graphs F 1 , … , F k such that for any graph G whether it is a Yes -instance of the query is already determined by the vector hom → F 1 , … , F k ( G ) : = ( hom ( F 1 , G ) , … , hom ( F k , G ) ) , where the graphs F 1 , … , F k only depend on φ . We observe that planarity of graphs and 3-colorability of graphs, properties expressible in monadic second-order logic, have no hom algorithm. We provide a characterization of the prefix classes of first-order logic with the property that each query definable by a sentence of the prefix class has a hom algorithm. For adaptive query algorithms, i.e., algorithms that again access hom → F 1 , … , F k ( G ) but here F i + 1 might depend on hom ( F 1 , G ) , … , hom ( F i , G ) , we show that three homomorphism counts hom ( ⋅ , G ) are both sufficient and in general necessary to determine the isomorphism type of G .},
  archive      = {J_IANDC},
  author       = {Yijia Chen and Jörg Flum and Mingjun Liu and Zhiyang Xun},
  doi          = {10.1016/j.ic.2025.105326},
  journal      = {Information and Computation},
  month        = {9},
  pages        = {105326},
  shortjournal = {Inf. Comput.},
  title        = {On algorithms based on finitely many homomorphism counts},
  volume       = {306},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Preface to special issue MFCS 2023. <em>IANDC</em>, <em>306</em>, 105325. (<a href='https://doi.org/10.1016/j.ic.2025.105325'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  archive      = {J_IANDC},
  author       = {Jérôme Leroux and David Peleg},
  doi          = {10.1016/j.ic.2025.105325},
  journal      = {Information and Computation},
  month        = {9},
  pages        = {105325},
  shortjournal = {Inf. Comput.},
  title        = {Preface to special issue MFCS 2023},
  volume       = {306},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Exploiting pseudo-locality of interchange distance. <em>IANDC</em>, <em>306</em>, 105324. (<a href='https://doi.org/10.1016/j.ic.2025.105324'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The goal of this paper is to examine how to exploit pseudo-locality in order to transform tools designed for the Hamming distance into tools adequate for the interchange distance, which is a pseudo-local metric. Intuitively, operators of pseudo-local string rearrangement distance measures have a bounded effect on the Hamming distance between the string prior to the operator application and after it. Specifically, we demonstrate a way to exploit pseudo-locality of the interchange distance combined with additional techniques to derive: 1. The first efficient approximate nearest-neighbor (ANN) data structure for the interchange distance, which is NP -hard to compute for general strings. 2. The first linear-time approximation algorithm to compute approximate pattern matching with interchanges, which is a vast improvement from the Θ ( n m ) -time known algorithm, where n and m are the text and the pattern length, respectively.},
  archive      = {J_IANDC},
  author       = {Avivit Levy},
  doi          = {10.1016/j.ic.2025.105324},
  journal      = {Information and Computation},
  month        = {9},
  pages        = {105324},
  shortjournal = {Inf. Comput.},
  title        = {Exploiting pseudo-locality of interchange distance},
  volume       = {306},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Linear programming of monitoring the links of a fractional weighted network using distance. <em>IANDC</em>, <em>306</em>, 105323. (<a href='https://doi.org/10.1016/j.ic.2025.105323'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In 2022, Foucaud et al. initiated the study of a new graph-theoretic concept called distance-edge-monitoring number (DEM number for short), in the area of network monitoring. In this paper, we study linear programming for the distance-edge-monitoring problem. For a connected graph G = ( V ( G ) , E ( G ) ) , let h be a function that assigns to each vertex v ∈ V ( G ) a number in [ 0 , 1 ] . For a vertex subset X ⊆ V ( G ) , denote h ( X ) = Σ v ∈ X h ( v ) . Then, the function h is called a monitoring function of G , if for any edge e in G , the weights of these vertices which monitoring the edge e are at least 1. The fractional distance-edge-monitoring number (FDEM number for short) of G , denoted by dem f ( G ) , is given by dem f ( G ) = min ⁡ { H | h is a monitoring function of G } , where H = h ( V ( G ) ) . In this paper, we obtain some bounds or exact values for the FDEM number of some specific graphs or networks. Moreover, we study the graphs where the FDEM number equals to the DEM number. Finally, we investigate the FDEM number of some convex polytopes.},
  archive      = {J_IANDC},
  author       = {Wen Li and Yaping Mao and Ralf Klasing},
  doi          = {10.1016/j.ic.2025.105323},
  journal      = {Information and Computation},
  month        = {9},
  pages        = {105323},
  shortjournal = {Inf. Comput.},
  title        = {Linear programming of monitoring the links of a fractional weighted network using distance},
  volume       = {306},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Parikh one-counter automata. <em>IANDC</em>, <em>306</em>, 105322. (<a href='https://doi.org/10.1016/j.ic.2025.105322'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Counting abilities in finite automata are traditionally provided by two orthogonal extensions: adding a single counter that can be tested for zeroness at any point, or adding Z -valued counters that are tested for equality only at the end of runs. In this paper, finite automata extended with both types of counters are introduced. They are called Parikh One-Counter Automata (POCA): the “Parikh” part referring to the evaluation of counters at the end of runs, and the “One-Counter” part to the single counter that can be tested during runs. Their expressiveness, in the deterministic and nondeterministic variants, is investigated; it is shown in particular that there are deterministic POCA languages that cannot be expressed without nondeterminism in the original models. The natural decision problems are also studied; strikingly, most of them are no harder than in the original models. A parametric version of nonemptiness is also considered.},
  archive      = {J_IANDC},
  author       = {Michaël Cadilhac and Arka Ghosh and Guillermo A. Pérez and Ritam Raha},
  doi          = {10.1016/j.ic.2025.105322},
  journal      = {Information and Computation},
  month        = {9},
  pages        = {105322},
  shortjournal = {Inf. Comput.},
  title        = {Parikh one-counter automata},
  volume       = {306},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). The longest subsequence-duplicated subsequence and related problems. <em>IANDC</em>, <em>306</em>, 105313. (<a href='https://doi.org/10.1016/j.ic.2025.105313'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Motivated by computing duplication patterns in sequences, a new fundamental problem called the longest subsequence-duplicated subsequence (LSDS) is proposed. Given a sequence S of length n , a subsequence-duplicated subsequence is a subsequence of S in the form of x 1 d 1 x 2 d 2 ⋯ x k d k with x i being a subsequence of S , x j ≠ x j + 1 and d i ≥ 2 for all i in [ k ] and j in [ k − 1 ] . We first present an O ( n 6 ) time algorithm to compute the longest cubic subsequences of all the O ( n 2 ) substrings of S , improving the trivial O ( n 7 ) bound. Then, an O ( n 6 ) time algorithm for computing the longest subsequence-duplicated subsequence (LSDS) of S is obtained. Finally we focus on two variants of this problem. We first consider the constrained version when Σ is unbounded, each letter appears in S at most d times and all the letters in Σ must appear in the solution. We show that the problem is NP-hard for d = 4 , via a reduction from a special version of SAT (which is obtained from 3-COLORING). We then show that when each letter appears in S at most d = 3 times, then the problem is solvable in O ( n 4 ) time.},
  archive      = {J_IANDC},
  author       = {Manuel Lafond and Wenfeng Lai and Adiesha Liyanage and Binhai Zhu},
  doi          = {10.1016/j.ic.2025.105313},
  journal      = {Information and Computation},
  month        = {9},
  pages        = {105313},
  shortjournal = {Inf. Comput.},
  title        = {The longest subsequence-duplicated subsequence and related problems},
  volume       = {306},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Probabilistic input-driven pushdown automata. <em>IANDC</em>, <em>305</em>, 105312. (<a href='https://doi.org/10.1016/j.ic.2025.105312'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A probabilistic variant of input-driven pushdown automata (IDPDA), also known as visibly pushdown automata, is introduced. It is proved that these automata can be determinized: an n -state probabilistic IDPDA that accepts each string with probability at least λ + δ or at most λ − δ , for some isolated cut-point λ ∈ [ 0 , 1 ] with δ > 0 , is transformed to a deterministic IDPDA recognizing the same language, with at most ( 1 + 1 δ ) n 2 − n states and at most | Σ + 1 | ⋅ ( 1 + 1 δ ) n 2 − n stack symbols, where Σ + 1 is the set of left bracket symbols in the alphabet. An asymptotically close lower bound is provided: for infinitely many n , there is a probabilistic IDPDA with 2 n + 3 states and n stack symbols, and with δ = 1 270 n , such that every equivalent deterministic IDPDA needs at least 7 n 2 / 14 states and at least n stack symbols. A few special cases of automata with reduced determinization complexity are identified.},
  archive      = {J_IANDC},
  author       = {Alex Rose and Alexander Okhotin},
  doi          = {10.1016/j.ic.2025.105312},
  journal      = {Information and Computation},
  month        = {6},
  pages        = {105312},
  shortjournal = {Inf. Comput.},
  title        = {Probabilistic input-driven pushdown automata},
  volume       = {305},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). The generalized constrained longest common subsequence in the run-length encoded format. <em>IANDC</em>, <em>305</em>, 105311. (<a href='https://doi.org/10.1016/j.ic.2025.105311'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The longest common subsequence (LCS) is commonly used as a similarity measurement between two given sequences (strings). Several variants of the LCS problem have been developed. The generalized constrained LCS (CLCS) problems have four variants: substring exclusion (STR-EC-LCS), substring inclusion, subsequence exclusion and subsequence inclusion. In the STR-EC-LCS problem, a given constraint string is excluded as a substring from the answer. For the STR-EC-LCS problem with run-length encoded (RLE) strings, we are given two strings X and Y , along with a constraint string P , consisting of M , N and R runs, respectively. In their plain (non-RLE) representations, the lengths of these strings are | X | = m , | Y | = n and | P | = r . We combine the state transition with the dynamic programming approach to solve the STR-EC-LCS problem with RLE strings. The time complexity of our algorithm is O ( r ( M n + m N ) ) . The previous algorithm for STR-EC-LCS without RLE has a time complexity of O ( m n r ) . Since M ≤ m and N ≤ n , our algorithm improves the previous algorithm in time complexity. Additionally, our algorithm, which is based on state transitions, is universal and can be applied to the other three variants of the generalized constrained LCS problem with the same complexity.},
  archive      = {J_IANDC},
  author       = {En-An Song and Chang-Biau Yang and Kuo-Tsung Tseng},
  doi          = {10.1016/j.ic.2025.105311},
  journal      = {Information and Computation},
  month        = {6},
  pages        = {105311},
  shortjournal = {Inf. Comput.},
  title        = {The generalized constrained longest common subsequence in the run-length encoded format},
  volume       = {305},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Measuring the expressive power of practical regular expressions by classical stacking automata models. <em>IANDC</em>, <em>305</em>, 105303. (<a href='https://doi.org/10.1016/j.ic.2025.105303'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A rewb is a regular expression extended with a feature called backreference. It is broadly known that backreference is a practical extension of regular expressions, and is supported by most modern regular expression engines, such as those in the standard libraries of Java, Python, and more. Meanwhile, indexed languages are the languages generated by indexed grammars, a formal grammar class proposed by A.V. Aho. We show that these two models' expressive powers are related in the following way: every language described by a rewb is an indexed language. As the smallest formal grammar class previously known to contain rewbs is the class of context sensitive languages, our result strictly improves the known upper-bound. Moreover, we prove the following four claims: (1) there exists a rewb whose language does not belong to the class of stack languages, which is a proper subclass of indexed languages, (2) the language described by a rewb without a captured reference is in the class of nonerasing stack languages, which is a proper subclass of stack languages, (3) there exists a rewb that describes a stack language but not a nonerasing stack language, and (4) a rewb extended with another practical extension called lookaheads can describe a non-indexed language. Finally, we show that the hierarchy investigated in a prior study, which separates the expressive power of rewbs by the notion of nested levels, is within the class of nonerasing stack languages.},
  archive      = {J_IANDC},
  author       = {Taisei Nogami and Tachio Terauchi},
  doi          = {10.1016/j.ic.2025.105303},
  journal      = {Information and Computation},
  month        = {6},
  pages        = {105303},
  shortjournal = {Inf. Comput.},
  title        = {Measuring the expressive power of practical regular expressions by classical stacking automata models},
  volume       = {305},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Further results on the hunters and rabbit game through monotonicity. <em>IANDC</em>, <em>305</em>, 105302. (<a href='https://doi.org/10.1016/j.ic.2025.105302'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The Hunters and Rabbit game is played on a graph G where the Hunter player shoots at k vertices in every round while the Rabbit player occupies an unknown vertex and, if not shot, must move to a neighbouring vertex. The Rabbit player wins if and only if it is not shot indefinitely. The hunter number h ( G ) of a graph G is the minimum k such that the Hunter player has a winning strategy. We propose a notion of monotonicity, embodied in the monotone hunter number m h ( G ) , for this game imposing that a vertex that has already been shot “must not host the rabbit anymore”. We show that p w ( G ) ≤ m h ( G ) ≤ p w ( G ) + 1 for any graph G with pathwidth p w ( G ) , implying that computing, or even approximating, m h ( G ) is NP -hard. Then, we show that m h ( G ) can be computed in polynomial time in split graphs, interval graphs, cographs and trees. These results go through structural characterisations which relate the monotone hunter number with the pathwidth. In all these cases, we either specify the hunter number or show that there may be an arbitrary gap between h and mh , i.e., that monotonicity does not help. In particular, for every k ≥ 3 , we construct a tree T with h ( T ) = 2 and m h ( T ) = k . We conclude by proving that computing h (resp., mh ) is FPT parameterised by the vertex cover number.},
  archive      = {J_IANDC},
  author       = {Thomas Dissaux and Foivos Fioravantes and Harmender Gahlawat and Nicolas Nisse},
  doi          = {10.1016/j.ic.2025.105302},
  journal      = {Information and Computation},
  month        = {6},
  pages        = {105302},
  shortjournal = {Inf. Comput.},
  title        = {Further results on the hunters and rabbit game through monotonicity},
  volume       = {305},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Chained time lock puzzle with small puzzle size. <em>IANDC</em>, <em>304</em>, 105301. (<a href='https://doi.org/10.1016/j.ic.2025.105301'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A time lock puzzle (TLP) is an interesting cryptographic primitive used to lock messages for a limited time period. After the desired time interval, the puzzle solver can know the message. Chained time lock puzzle (C-TLP) is multi instance time lock puzzle where the solution of any instance depends on the previous instance. In this paper, we design a C-TLP with security relying on the integer factorization problem (IFP). The size of the output puzzle is smaller than the size in the existing C-TLPs.},
  archive      = {J_IANDC},
  author       = {Ramakant Kumar and Sahadeo Padhye},
  doi          = {10.1016/j.ic.2025.105301},
  journal      = {Information and Computation},
  month        = {5},
  pages        = {105301},
  shortjournal = {Inf. Comput.},
  title        = {Chained time lock puzzle with small puzzle size},
  volume       = {304},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Modules and PQ-trees in robinson spaces. <em>IANDC</em>, <em>304</em>, 105300. (<a href='https://doi.org/10.1016/j.ic.2025.105300'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A Robinson space is a dissimilarity space ( X , d ) on n points for which there exists a compatible order, i.e. a total order < on X such that x < y < z implies that d ( x , y ) ≤ d ( x , z ) and d ( y , z ) ≤ d ( x , z ) . Recognizing whether a dissimilarity space is Robinson has numerous applications in seriation and classification. The set of all compatible orders of a Robinson space can be succintly represented by a PQ-tree, a classical data structure introduced by Booth and Lueker. An mmodule is a subset M of X which is not distinguishable from the outside of M , i.e. the distances from any point of X ∖ M to all points of M are the same. The hierarchical structure of mmodules can also be represented by a tree: the mmodule-tree of a dissimilarity space ( X , d ) . In this paper, we establish correspondences between the PQ-trees and the mmodule-trees of Robinson spaces. More precisely, we show how to construct the mmodule-tree of a Robinson dissimilarity from its PQ-tree and vice versa . To establish this translation, we introduce the notions of δ -graph G δ ‾ of a Robinson space and of δ -mmodules, the connected components of G δ ‾ . It also involves the dendrogram of the subdominant ultrametric of d . All these results also lead to optimal O ( n 2 ) time algorithms for constructing the PQ-tree and the mmodule tree of Robinson spaces.},
  archive      = {J_IANDC},
  author       = {M. Carmona and V. Chepoi and G. Naves and P. Préa},
  doi          = {10.1016/j.ic.2025.105300},
  journal      = {Information and Computation},
  month        = {5},
  pages        = {105300},
  shortjournal = {Inf. Comput.},
  title        = {Modules and PQ-trees in robinson spaces},
  volume       = {304},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Set semantics for asynchronous TeamLTL: Expressivity and complexity. <em>IANDC</em>, <em>304</em>, 105299. (<a href='https://doi.org/10.1016/j.ic.2025.105299'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We introduce and develop a set-based semantics for asynchronous TeamLTL. We consider two canonical logics in this setting: the extensions of TeamLTL by the Boolean disjunction and by the Boolean negation. We relate the new semantics with the original semantics based on multisets and establish one of the first positive complexity theoretic results in the temporal team semantics setting. In particular we show that both logics enjoy normal forms that can be utilised to obtain results related to expressivity and complexity (decidability) of the new logics.},
  archive      = {J_IANDC},
  author       = {Juha Kontinen and Max Sandström and Jonni Virtema},
  doi          = {10.1016/j.ic.2025.105299},
  journal      = {Information and Computation},
  month        = {5},
  pages        = {105299},
  shortjournal = {Inf. Comput.},
  title        = {Set semantics for asynchronous TeamLTL: Expressivity and complexity},
  volume       = {304},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). The geometry of reachability in continuous vector addition systems with states. <em>IANDC</em>, <em>304</em>, 105298. (<a href='https://doi.org/10.1016/j.ic.2025.105298'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We study the geometry of reachability sets of continuous vector addition systems with states (VASS). In particular we establish that they are “almost” Minkowski sums of convex cones and zonotopes generated by the vectors labelling the transitions of the VASS. We use the latter to prove that short so-called linear path schemes suffice as witnesses of reachability in continuous VASS. Then, we give new polynomial-time algorithms for the reachability problem for linear path schemes. Finally, we also establish that enriching the model with zero tests makes the reachability problem intractable already for linear path schemes of dimension two.},
  archive      = {J_IANDC},
  author       = {Shaull Almagor and Arka Ghosh and Tim Leys and Guillermo A. Pérez},
  doi          = {10.1016/j.ic.2025.105298},
  journal      = {Information and Computation},
  month        = {5},
  pages        = {105298},
  shortjournal = {Inf. Comput.},
  title        = {The geometry of reachability in continuous vector addition systems with states},
  volume       = {304},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). On the data persistency of replicated erasure codes in distributed storage systems. <em>IANDC</em>, <em>304</em>, 105297. (<a href='https://doi.org/10.1016/j.ic.2025.105297'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {This paper studies the fundamental problem of data persistency for a general family of redundancy schemes, called replicated erasure codes . In replicated erasure codes each document is divided into p chunks and then encoded into p + q chunks. Then, each of the p + q chunks is replicated into r replicas. We analyze two strategies of replicated erasure codes distribution: random (all chunks are spread randomly among storage nodes) and sequential (the chunks are sequentially placed into storage nodes). For both strategies we derive closed-form expression and asymptotic bounds for expected data persistency of replicated erasure codes when the storage nodes leave the storage system and erase their locally stored data. We observe that the maximal expected data persistency of replicated erasure codes for both placement strategies is attained for parameter p = 1 and give formulas in terms of the beta function in this case.},
  archive      = {J_IANDC},
  author       = {Roy Friedman and Rafał Kapelko and Karol Marchwicki},
  doi          = {10.1016/j.ic.2025.105297},
  journal      = {Information and Computation},
  month        = {5},
  pages        = {105297},
  shortjournal = {Inf. Comput.},
  title        = {On the data persistency of replicated erasure codes in distributed storage systems},
  volume       = {304},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Elastic-degenerate string comparison. <em>IANDC</em>, <em>304</em>, 105296. (<a href='https://doi.org/10.1016/j.ic.2025.105296'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {An elastic-degenerate (ED) string T is a sequence of n sets T [ 1 ] , … , T [ n ] containing m strings in total whose cumulative length is N . We call n , m , and N the length, the cardinality and the size of T , respectively. The language of T is defined as L ( T ) = { S 1 ⋯ S n : S i ∈ T [ i ] for all i ∈ [ 1 , n ] } . Given two ED strings, how fast can we check whether the two languages they represent have a nonempty intersection? We call this problem the ED String Intersection (EDSI) problem. For two ED strings T 1 and T 2 of lengths n 1 and n 2 , cardinalities m 1 and m 2 , and sizes N 1 and N 2 , respectively, we show the following: • There is no O ( ( N 1 N 2 ) 1 − ϵ ) -time algorithm, for any ϵ > 0 , for EDSI even if T 1 and T 2 are over a binary alphabet, unless the Strong Exponential-Time Hypothesis is false. • There is no combinatorial O ( ( N 1 + N 2 ) 1.2 − ϵ f ( n 1 , n 2 ) ) -time algorithm, for any ϵ > 0 and any function f , for EDSI even if T 1 and T 2 are over a binary alphabet, unless the Boolean Matrix Multiplication conjecture is false. • An O ( N 1 log ⁡ N 1 log ⁡ n 1 + N 2 log ⁡ N 2 log ⁡ n 2 ) -time algorithm for outputting a compact representation of the intersection language of two unary ED strings. When T 1 and T 2 are given in a compact representation, we show that the problem is NP-complete. • An O ( N 1 m 2 + N 2 m 1 ) -time algorithm for EDSI. • An O ˜ ( N 1 ω − 1 n 2 + N 2 ω − 1 n 1 ) -time algorithm for EDSI, where ω is the matrix multiplication exponent; the O ˜ notation suppresses factors that are polylogarithmic in the input size.},
  archive      = {J_IANDC},
  author       = {Estéban Gabory and Moses Njagi Mwaniki and Nadia Pisanti and Solon P. Pissis and Jakub Radoszewski and Michelle Sweering and Wiktor Zuba},
  doi          = {10.1016/j.ic.2025.105296},
  journal      = {Information and Computation},
  month        = {5},
  pages        = {105296},
  shortjournal = {Inf. Comput.},
  title        = {Elastic-degenerate string comparison},
  volume       = {304},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Derandomization of quantum algorithm for triangle finding. <em>IANDC</em>, <em>304</em>, 105295. (<a href='https://doi.org/10.1016/j.ic.2025.105295'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Derandomization is the process of taking a randomized algorithm and turning it into a deterministic algorithm, which has attracted great attention in classical computing. In quantum computing, it is challenging and intriguing to derandomize quantum algorithms, due to the inherent randomness of quantum mechanics. The significance of derandomizing quantum algorithms lies not only in theoretically proving that the success probability can essentially be 1 without sacrificing quantum speedups, but also in experimentally improving the success rate when the algorithm is implemented on a real quantum computer. In this paper, we focus on derandomizing quantum algorithms for the triangle sum problem (including the famous triangle finding problem as a special case), which asks to find a triangle in an edge-weighted graph with n vertices, such that its edges sum up to a given weight. We show that when the graph is promised to contain at most one target triangle, there exists a deterministic quantum algorithm that either finds the triangle if it exists or outputs “no triangle” if none exists. It makes O ( n 9 / 7 ) queries to the edge weight matrix oracle, and thus has the same complexity as the state-of-the-art bounded-error quantum algorithm. To achieve this derandomization, we make full use of several techniques: nested quantum walk with quantum data structure, deterministic quantum search with adjustable parameters, and dimensional reduction of quantum walk search on Johnson graph.},
  archive      = {J_IANDC},
  author       = {Guanzhong Li and Lvzhou Li},
  doi          = {10.1016/j.ic.2025.105295},
  journal      = {Information and Computation},
  month        = {5},
  pages        = {105295},
  shortjournal = {Inf. Comput.},
  title        = {Derandomization of quantum algorithm for triangle finding},
  volume       = {304},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Collision-free robot scheduling. <em>IANDC</em>, <em>304</em>, 105294. (<a href='https://doi.org/10.1016/j.ic.2025.105294'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this paper, we investigate the problem of designing schedules for completing a set of tasks at fixed locations with multiple robots in a laboratory. We represent the laboratory as a graph with tasks placed on fixed vertices and robots represented as agents, with the constraint that no two robots may occupy the same vertex at any given timestep. Each schedule is partitioned into a set of timesteps, corresponding to a walk through the graph (allowing for a robot to wait at a vertex to complete a task), with each timestep taking time equal to the time for a robot to move from one vertex to another and each task taking some given number of timesteps during the completion of which a robot must stay at the vertex containing the task. The goal is to determine a set of schedules, with one schedule for each robot, minimising the number of timesteps taken by the schedule taking the greatest number of timesteps within the set of schedules. We show that this problem is NP-complete for both star graphs (for k ≥ 2 robots), and planar graphs (for any number of robots). Finally, we provide positive results for path, cycle, and tadpole graphs, showing that we can find an optimal set of schedules for k robots completing m tasks of equal duration of a path of length n in O ( k m n ) , O ( k m n 2 ) time, and O ( k 3 m 4 n ) time respectively.},
  archive      = {J_IANDC},
  author       = {Duncan Adamson and Nathan Flaherty and Igor Potapov and Paul G. Spirakis},
  doi          = {10.1016/j.ic.2025.105294},
  journal      = {Information and Computation},
  month        = {5},
  pages        = {105294},
  shortjournal = {Inf. Comput.},
  title        = {Collision-free robot scheduling},
  volume       = {304},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). A dichotomy result for countably based sober spaces. <em>IANDC</em>, <em>304</em>, 105293. (<a href='https://doi.org/10.1016/j.ic.2025.105293'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Cartesian closed categories have been playing fundamental roles in providing denotational semantic for higher-order programming languages. In this paper we try to identify Cartesian closed subcategories of the category C S ⊥ of pointed countably based sober spaces, and we present a conclusion known as the dichotomy result in the category C S ⊥ . This result explains that any Cartesian closed full subcategory of C S ⊥ is contained within either the category of weakly compact open connected spaces or that of principally connected spaces. To prove our dichotomy theorem, we first deduce that every pointed countably based sober space X is locally connected, if the space of all continuous functions from X to X is locally compact. Next, we demonstrate that a function space in C S ⊥ is locally connected only if its input space is either weakly compact open connected or its output space is principally connected.},
  archive      = {J_IANDC},
  author       = {Hualin Miao and Qingguo Li},
  doi          = {10.1016/j.ic.2025.105293},
  journal      = {Information and Computation},
  month        = {5},
  pages        = {105293},
  shortjournal = {Inf. Comput.},
  title        = {A dichotomy result for countably based sober spaces},
  volume       = {304},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). A multivariate convertible undeniable signature scheme. <em>IANDC</em>, <em>304</em>, 105286. (<a href='https://doi.org/10.1016/j.ic.2025.105286'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Digital signature is an important cryptographic primitive which can be universally verified. However, this universal verifiability can be ominous in case of e-auction, e-voting, and e-cash, where the verifiability must be restricted. Undeniable signature is a type of digital signature that is mainly used to achieve the goal of access control. In this article, we propose the first multivariate-based quantum secure undeniable signature scheme, which can also be converted into an ordinary signature. The security of this scheme relies on the hardness of multivariate quadratic problem which is computationally hard to solve when defined over any finite field. We deploy Monteiro et al.'s improvement on Sakumoto et al.'s zero-knowledge protocol for the verification process. We discuss the security properties of undeniable signature, viz., completeness, soundness, unforgeability, invisibility, and non-impersonation. Additionally, we show that the proposed undeniable signature has the smallest signature and key sizes among all the existing quantum-resistant undeniable signatures.},
  archive      = {J_IANDC},
  author       = {Satyam Omar and Sahadeo Padhye and Dhananjoy Dey and Devansh Mehrotra},
  doi          = {10.1016/j.ic.2025.105286},
  journal      = {Information and Computation},
  month        = {5},
  pages        = {105286},
  shortjournal = {Inf. Comput.},
  title        = {A multivariate convertible undeniable signature scheme},
  volume       = {304},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Composing bridges. <em>IANDC</em>, <em>304</em>, 105285. (<a href='https://doi.org/10.1016/j.ic.2025.105285'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The present work builds on previous investigations of the authors (and their collaborators) regarding bridges, a certain type of morphisms between encryption schemes, making a step forward in developing a (category theory) language for studying relations between encryption schemes. Here we analyse the conditions under which bridges can be performed sequentially, formalizing the notion of composability. One of our results gives a sufficient condition for a pair of bridges to be composable. We illustrate that composing two bridges, each independently satisfying a previously established IND-CPA security definition, can actually lead to an insecure bridge. Our main result gives a sufficient condition that a pair of secure composable bridges should satisfy in order for their composition to be a secure bridge. We also introduce the concept of a complete bridge and show that it is connected to the notion of Fully composable Homomorphic Encryption (FcHE), recently considered by Micciancio. Moreover, we show that a result of Micciancio which gives a construction of FcHE schemes can be phrased in the language of complete bridges, where his insights can be formalized in a greater generality.},
  archive      = {J_IANDC},
  author       = {Mugurel Barcau and Vicenţiu Paşol and George C. Ţurcaş},
  doi          = {10.1016/j.ic.2025.105285},
  journal      = {Information and Computation},
  month        = {5},
  pages        = {105285},
  shortjournal = {Inf. Comput.},
  title        = {Composing bridges},
  volume       = {304},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Identity based proxy blind signature scheme using NTRU lattices. <em>IANDC</em>, <em>304</em>, 105284. (<a href='https://doi.org/10.1016/j.ic.2025.105284'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Proxy blind signatures represent a specific type of blind signature that allows a proxy signer to sign documents on behalf of the original signer without having access to the content they are signing. Currently, most of the existing proxy blind signature schemes rely on complex number-theoretic hard problems like bilinear pairing and the discrete logarithm problem or on general lattices' hardness. Unfortunately, the security of number-theoretic hard problems-based systems is struggling due to vulnerability to Shor's algorithm, which jeopardizes the security of cryptographic schemes based on them, and general lattices suffer from large key sizes. Thus, we are looking for a new scheme that is efficient in time and storage, has short key and signature sizes, and is crucially secure against threats posed by quantum computers. Recently, NTRU lattice-based schemes have gained significant popularity due to their ease of implementation and proven security reductions. In 2018, Zhu et al. presented an identity-based proxy blind signature scheme over NTRU lattices, which is not secure. Therefore, by explaining the security breach of Zhu et al.'s scheme, we present a novel, secure, and improved identity-based proxy blind signature system resistant to quantum threats and utilizing NTRU lattices. Based on the standard hardness assumptions related to the approximate shortest vector problem ( γ -SVP) and the shortest integer solution problem (SIS), it is demonstrated that the proposed method is secure against quantum forgery.},
  archive      = {J_IANDC},
  author       = {Sonika Singh and Swati Rawal and Sahadeo Padhye and Namita Tiwari},
  doi          = {10.1016/j.ic.2025.105284},
  journal      = {Information and Computation},
  month        = {5},
  pages        = {105284},
  shortjournal = {Inf. Comput.},
  title        = {Identity based proxy blind signature scheme using NTRU lattices},
  volume       = {304},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Computing maximal palindromes in non-standard matching models. <em>IANDC</em>, <em>304</em>, 105283. (<a href='https://doi.org/10.1016/j.ic.2025.105283'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Palindromes are popular and important objects in textual data processing, bioinformatics, and combinatorics on words. Let S = X a Y be a string where X and Y are of the same length, and a is either a single character or the empty string. Then, there exist two alternative definitions for palindromes: S is said to be a palindrome if S is equal to its reversal S R (Reversal-based definition); or if its right-arm Y is equal to the reversal of its left-arm X R (Symmetry-based definition). It is clear that if the “equality” (≈) used in both definitions is exact character matching (=), then the two definitions are the same. However, if we apply other string-equality criteria ≈, including the complementary-matching model for biological sequences, the Cartesian-tree model [Park et al., TCS 2020], the parameterized model [Baker, JCSS 1996], the order-preserving model [Kim et al., TCS 2014], and the palindromic-structure model [I et al., TCS 2013], then are the reversal-based palindromes and the symmetry-based palindromes the same? To the best of our knowledge, no previous work has considered or answered this natural question. In this paper, we first provide answers to this question, and then present efficient algorithms for computing all maximal palindromes under the non-standard matching models in a given string. After confirming that Gusfield's offline suffix-tree-based algorithm for computing maximal symmetry-based palindromes can be readily extended to the aforementioned matching models, we show how to extend Manacher's online algorithm for computing maximal reversal-based palindromes in linear time for all the aforementioned matching models.},
  archive      = {J_IANDC},
  author       = {Takuya Mieno and Mitsuru Funakoshi and Yuto Nakashima and Shunsuke Inenaga and Hideo Bannai and Masayuki Takeda},
  doi          = {10.1016/j.ic.2025.105283},
  journal      = {Information and Computation},
  month        = {5},
  pages        = {105283},
  shortjournal = {Inf. Comput.},
  title        = {Computing maximal palindromes in non-standard matching models},
  volume       = {304},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Polynomial-delay enumeration of large maximal common independent sets in two matroids and beyond. <em>IANDC</em>, <em>304</em>, 105282. (<a href='https://doi.org/10.1016/j.ic.2025.105282'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Finding a maximum cardinality common independent set in two matroids (also known as Matroid Intersection ) is a classical combinatorial optimization problem, which generalizes several well-known problems, such as finding a maximum bipartite matching, a maximum colorful forest, and an arborescence in directed graphs. Enumerating all maximal common independent sets in two (or more) matroids is a classical enumeration problem. In this paper, we address an “intersection” of these problems: Given two matroids and a threshold τ , the goal is to enumerate all maximal common independent sets in the matroids with cardinality at least τ . We show that this problem can be solved in polynomial delay and polynomial space. Moreover, our technique can be extended to a more general problem, which is relevant to Matroid Matching . We give a polynomial-delay and polynomial-space algorithm for enumerating all maximal “matchings” with cardinality at least τ , assuming that the optimization counterpart is “tractable” in a certain sense. This extension allows us to enumerate small minimal connected vertex covers in subcubic graphs. We also discuss a framework to convert enumeration with cardinality constraints into ranked enumeration.},
  archive      = {J_IANDC},
  author       = {Yasuaki Kobayashi and Kazuhiro Kurita and Kunihiro Wasa},
  doi          = {10.1016/j.ic.2025.105282},
  journal      = {Information and Computation},
  month        = {5},
  pages        = {105282},
  shortjournal = {Inf. Comput.},
  title        = {Polynomial-delay enumeration of large maximal common independent sets in two matroids and beyond},
  volume       = {304},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Homogeneous spiking neural p systems with synaptic failure. <em>IANDC</em>, <em>304</em>, 105281. (<a href='https://doi.org/10.1016/j.ic.2025.105281'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Spiking neural P (SN P) systems are a class of neural-like computational models, inspired by the way biological neurons process information through electrical impulses known as spikes. Homogeneous spiking neural P (HSN P) systems are a specialized variant of SN P systems, where all neurons share the same set of rules. In this work, with the biological inspiration that excessive synaptic transmission can lead to short-term failures in signal delivery between neurons in neural systems, the notion of synaptic failure is considered in HSN P systems, termed HSN P systems with synaptic failure (HSNPSF systems). Specifically, synaptic failure is referred to a family of sets of failure-prone synapses: if spikes simultaneously pass along all the synapses in such a set, the transmitted spikes across the synapses are suppressed; if a synapse in the set does not transmit any spike, the spikes pass along the synapses at that time, ultimately reaching the destination neurons. The computational power of HSNPSF systems is investigated by proving that they can achieve computational completeness both in generating and accepting modes. Furthermore, the computational efficiency of HSNPSF systems is examined, and it is demonstrated that with the help of non-deterministic feature, these systems are capable of solving NP -complete (the Subset Sum) problem in a semi-uniform way and within constant time.},
  archive      = {J_IANDC},
  author       = {Luping Zhang and Tingfang Wu},
  doi          = {10.1016/j.ic.2025.105281},
  journal      = {Information and Computation},
  month        = {5},
  pages        = {105281},
  shortjournal = {Inf. Comput.},
  title        = {Homogeneous spiking neural p systems with synaptic failure},
  volume       = {304},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). On the computational power of energy-constrained mobile robots. <em>IANDC</em>, <em>303</em>, 105280. (<a href='https://doi.org/10.1016/j.ic.2025.105280'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We consider distributed systems of autonomous robots operating in the plane under synchronous Look - Compute - Move ( LCM ) cycles. Prior research on four distinct models assumes robots have unlimited energy. We remove this assumption and investigate systems where robots have limited but renewable energy, requiring inactivity for energy restoration. We analyze the computational impact of this constraint, fully characterizing the relationship between energy-restricted and unrestricted robots. Surprisingly, we show that energy constraints can enhance computational power. Additionally, we study how memory persistence and communication capabilities influence computation under energy constraints. By comparing the four models in this setting, we establish a complete characterization of their computational relationships. A key insight is that energy-limited robots can be modeled as unlimited-energy robots controlled by an adversarial activation scheduler. This provides a novel equivalence framework for analyzing energy-constrained distributed systems.},
  archive      = {J_IANDC},
  author       = {Kevin Buchin and Paola Flocchini and Irina Kostitsyna and Tom Peters and Nicola Santoro and Koichi Wada},
  doi          = {10.1016/j.ic.2025.105280},
  journal      = {Information and Computation},
  month        = {3},
  pages        = {105280},
  shortjournal = {Inf. Comput.},
  title        = {On the computational power of energy-constrained mobile robots},
  volume       = {303},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Consistent query answering in multi-relation databases. <em>IANDC</em>, <em>303</em>, 105279. (<a href='https://doi.org/10.1016/j.ic.2025.105279'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Traditionally, to verify the consistency of a multi-relation database with respect to a set of functional dependencies, one applies the well-known Chase algorithm, which derives new tuples as long as no conflict with some dependency arises. Therefore, the Chase algorithm uses dependencies both as inference rules and as tools to check consistency. If no conflicts occur, the database is declared consistent else inconsistent. If the database is consistent then query answering proceeds as usual, otherwise extracting consistent information from the inconsistent database is an issue, known as consistent query answering. To address this issue, we consider the set T of all tuples built from constants occurring in the database, and we use set theoretic semantics to characterize tuples in T in two orthogonal ways: true/false and conflicting/non-conflicting. Calling ‘consistent’ a tuple which is true and non-conflicting, a ‘repair’ is defined to be a maximal subset of true tuples that satisfies the dependencies and in which as many consitent tuples as possible are true. A query Q is of the form select X where C o n d i t i o n , and a tuple x of T is in the consistent answer of Q if x is in the answer of Q in every repair. Our main contributions are: (a) a novel approach to consistent query answering in multi-relation databases; (b) a modified Chase algorithm to compute true/false and conflicting/non-conflicting tuples; (c) for acyclic functional dependencies, a polynomial-time algorithm computing the exact or approximate consistent answers; (d) a detailed discussion comparing our approach with other related approaches.},
  archive      = {J_IANDC},
  author       = {Dominique Laurent and Nicolas Spyratos},
  doi          = {10.1016/j.ic.2025.105279},
  journal      = {Information and Computation},
  month        = {3},
  pages        = {105279},
  shortjournal = {Inf. Comput.},
  title        = {Consistent query answering in multi-relation databases},
  volume       = {303},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). On regular trees defined from unfoldings and coverings. <em>IANDC</em>, <em>303</em>, 105278. (<a href='https://doi.org/10.1016/j.ic.2025.105278'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We study the infinite trees that arise, first as complete unfoldings of finite weighted directed graphs, and second, as universal coverings of finite weighted undirected graphs. They are respectively the regular rooted trees and the strongly regular trees, a new notion. A rooted tree is regular if it has finitely many subtrees up to isomorphism. A tree (without root) is strongly regular if it has finitely many rooted trees, up to isomorphism, obtained by taking each of its nodes as a root. We prove the first-order definability of each regular or strongly regular tree with respect to the class of trees (that is not itself first-order definable). We characterize the strongly regular trees among the regular ones and we establish several decidability results.},
  archive      = {J_IANDC},
  author       = {Bruno Courcelle},
  doi          = {10.1016/j.ic.2025.105278},
  journal      = {Information and Computation},
  month        = {3},
  pages        = {105278},
  shortjournal = {Inf. Comput.},
  title        = {On regular trees defined from unfoldings and coverings},
  volume       = {303},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). The computational properties of p systems with mutative membrane structures. <em>IANDC</em>, <em>303</em>, 105277. (<a href='https://doi.org/10.1016/j.ic.2025.105277'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Membrane computing is a subfield of nature-inspired computing studying computational models named P systems , where several rules (division rules, dissolving rules, merging rules, creation rules, separation rules, etc) for evolving the membrane structure were considered in many variants of P systems, and most of these variants employ at most two of these types of rules. In this article, we combine budding rules, fusion rules, dissolving rules, division rules (both for non-elementary membrane and elementary membranes), therefore a mutative type of P systems, termed cell-like P systems with mutative membrane structures (CMMS P systems) are defined. We discuss the computational properties of CMMS P systems. More specifically, CMMS P systems are shown to be Turing universal by integrating some types of rules. Moreover, we prove that CMMS P systems can also effectively solve the SAT problem.},
  archive      = {J_IANDC},
  author       = {Bosheng Song and Chuanlong Hu and David Orellana-Martín and Antonio Ramírez-de-Arellano and Mario J. Pérez-Jiménez and Xiangxiang Zeng},
  doi          = {10.1016/j.ic.2025.105277},
  journal      = {Information and Computation},
  month        = {3},
  pages        = {105277},
  shortjournal = {Inf. Comput.},
  title        = {The computational properties of p systems with mutative membrane structures},
  volume       = {303},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Metric quantifiers and counting in timed logics and automata. <em>IANDC</em>, <em>303</em>, 105268. (<a href='https://doi.org/10.1016/j.ic.2025.105268'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We study the expressiveness of the pointwise interpretations (i.e. over timed words) of some predicate and temporal logics with metric and counting features. We show that counting in the unit interval ( 0 , 1 ) is strictly weaker than counting in ( 0 , b ) with arbitrary b ≥ 0 ; moreover, allowing the latter to be included in temporal logics leads to expressive completeness for the metric predicate logic Q2MLO , recovering the corresponding result for the continuous interpretations (i.e. over signals). Exploiting this connection, we show that in contrast to the continuous case, adding ‘punctual’ predicates into Q2MLO is still insufficient for the full expressive power of the Monadic First-Order Logic of Order and Metric ( FO[ < , + 1 ] ); as a remedy, we propose a generalisation of the recently proposed Pnueli automata modalities and show that the resulting metric temporal logic is expressively complete for FO[ < , + 1 ] . On the practical side, we propose a compositional construction from metric interval temporal logic with counting or similar extensions to timed automata, which is more amenable to implementation based on existing tools that support on-the-fly model checking.},
  archive      = {J_IANDC},
  author       = {Hsi-Ming Ho and Khushraj Madnani},
  doi          = {10.1016/j.ic.2025.105268},
  journal      = {Information and Computation},
  month        = {3},
  pages        = {105268},
  shortjournal = {Inf. Comput.},
  title        = {Metric quantifiers and counting in timed logics and automata},
  volume       = {303},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Generalising the maximum independent set algorithm via boolean networks. <em>IANDC</em>, <em>303</em>, 105266. (<a href='https://doi.org/10.1016/j.ic.2025.105266'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A simple greedy algorithm to find a maximal independent set (MIS) in a graph starts with the empty set and visits every vertex, adding it to the set if and only if none of its neighbours are already in the set. In this paper, we consider (the complexity of decision problems related to) the generalisation of this MIS algorithm wherein any starting set is allowed. Two main approaches are leveraged. Firstly, we view the MIS algorithm as a sequential update of a Boolean network according to a permutation of the vertex set. Secondly, we introduce the concept of a constituency of a graph: a set of vertices that is dominated by an independent set. Recognizing a constituency is NP -complete, a fact we leverage repeatedly in our investigation. Our contributions are multiple: we establish that deciding whether all maximal independent sets can be reached from some configuration is coNP -complete; that fixing words (which reach a MIS from any starting configuration) and fixing permutations (briefly, permises) are coNP -complete to recognize; and that permissible graphs (graphs with a permis) are coNP -hard to recognize. We also exhibit large classes of permissible and non-permissible graphs, notably near-comparability graphs which may be of independent interest. Lastly, we extend our study to digraphs, where we search for kernels. Since the natural generalisation of our approach may not necessarily find a kernel, we introduce two further Boolean networks for digraphs: one always finds an independent set, and the other always finds a dominating set.},
  archive      = {J_IANDC},
  author       = {Maximilien Gadouleau and David C. Kutner},
  doi          = {10.1016/j.ic.2025.105266},
  journal      = {Information and Computation},
  month        = {3},
  pages        = {105266},
  shortjournal = {Inf. Comput.},
  title        = {Generalising the maximum independent set algorithm via boolean networks},
  volume       = {303},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Efficient assignment of identities in anonymous populations. <em>IANDC</em>, <em>303</em>, 105265. (<a href='https://doi.org/10.1016/j.ic.2025.105265'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We consider the fundamental problem of assigning distinct labels to agents in the probabilistic model of population protocols. Our protocols operate under the assumption that the size n of the population is embedded in the transition function. W.h.p. (with high probability), they are silent, i.e., eventually each agent reaches its final state and remains in it forever, and they are safe, i.e., never change a label that has already been assigned to an agent. We provide efficient protocols for this problem complemented with tight lower bounds. Our fast labeling protocol uses only O ( ( n log ⁡ n ) / ε ) interactions w.h.p., ( 2 + ε ) n + O ( n a ) states, and the label range [ 1 , ( 1 + ε ) n ] , where 1 ≥ ε > 0 and 0 < a < 1 , while our nearly state-optimal protocol uses only n + 5 n + O ( log ⁡ log ⁡ n ) states, the label range [ 1 , n ] , and w.h.p., O ( n 3 ) interactions.},
  archive      = {J_IANDC},
  author       = {Leszek Gąsieniec and Jesper Jansson and Christos Levcopoulos and Andrzej Lingas},
  doi          = {10.1016/j.ic.2025.105265},
  journal      = {Information and Computation},
  month        = {3},
  pages        = {105265},
  shortjournal = {Inf. Comput.},
  title        = {Efficient assignment of identities in anonymous populations},
  volume       = {303},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Approximate envy-freeness in indivisible resource allocation with budget constraints. <em>IANDC</em>, <em>303</em>, 105264. (<a href='https://doi.org/10.1016/j.ic.2024.105264'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We study the fair allocation of indivisible resources under knapsack constraints, where a set of items with varied costs and values are to be allocated among a group of agents. Each agent has a budget constraint on the total cost of items she can receive. The goal is to compute a budget-feasible allocation that is envy-free (EF), in which the agents do not envy each other for the items they receive, nor do they envy a charity, which is endowed with all the unallocated items. Since EF allocations barely exist (even without the budget constraints), we are interested in the relaxed notion of envy-freeness up to one item (EF1). Our results are twofold. Firstly, for the general setting where agents have heterogeneous valuations and budgets, we show that a budget-feasible allocation that maximizes the Nash social welfare (NSW) achieves a 1/4-approximation of EF1. This approximation ratio carries to the general case of arbitrary monotone subadditive valuations. The approximation ratio improves gracefully when the items have small cost compared with the agents' budgets; it converges to 1/2 when the budget-cost ratio approaches infinity, and to 1 if the agents further have identical valuations. Secondly, when agents have identical valuations, we design a polynomial-time algorithm that computes a 1/2-approximate EF1 allocation for an arbitrary number of agents. For the case of identical agents and the case of two agents, we propose polynomial-time algorithms for computing EF1 allocations.},
  archive      = {J_IANDC},
  author       = {Xiaowei Wu and Bo Li and Jiarui Gan},
  doi          = {10.1016/j.ic.2024.105264},
  journal      = {Information and Computation},
  month        = {3},
  pages        = {105264},
  shortjournal = {Inf. Comput.},
  title        = {Approximate envy-freeness in indivisible resource allocation with budget constraints},
  volume       = {303},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Nondeterminism and the clique problem. <em>IANDC</em>, <em>303</em>, 105260. (<a href='https://doi.org/10.1016/j.ic.2024.105260'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The Clique problem is known to be NP-Complete and the question whether P=NP is unresolved. This paper examines the relative power of nondeterminism versus determinism in a restricted setting. Specifically, we consider solving the clique problem using non-deterministic and deterministic Turing machines. We impose a (reasonable) format in which a problem instance is encoded. We also impose constraints on the computation of both deterministic and non-deterministic Turing machines: both have two tapes, the input tape is read-only and one-way, and once a certain stop point in the input tape is reached, no additional writing on the work tape is allowed. We consider two cases for the position of the stop point: immediately after the number of graph nodes and the size of the clique are specified, or controlled by a parameter q that indicates what portion of the graph nodes' edge specifications have been scanned. The parameter q may be arbitrarily close to 1, e.g., q = 0.99999 . We show, for both cases in our setting, that a non-deterministic Turing machine can solve the problem in O ( n 3 ) time whereas no deterministic Turing machine can solve the problem in polynomial time. However, we exhibit an exponential time deterministic single work tape, two-heads Turing machine that solves the clique problem in our setting.},
  archive      = {J_IANDC},
  author       = {Oded Shmueli},
  doi          = {10.1016/j.ic.2024.105260},
  journal      = {Information and Computation},
  month        = {3},
  pages        = {105260},
  shortjournal = {Inf. Comput.},
  title        = {Nondeterminism and the clique problem},
  volume       = {303},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). An algebraic attack on the key exchange protocol based upon a modified tropical structure. <em>IANDC</em>, <em>303</em>, 105259. (<a href='https://doi.org/10.1016/j.ic.2024.105259'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this paper, we analyze the key exchange protocol based on an algebraic structure derived from a tropical semiring. The security of this key exchange scheme depends on an attacker's inability to solve a system of non-linear equations to obtain the private parameters. However, we propose an algebraic attack on this key exchange scheme using only the public parameters. We thoroughly evaluate the protocol's security against algebraic attacks through comprehensive cryptanalysis. We study the behavior of matrix sequences produced during key exchange, looking for any almost linear periodicity property that could affect the cryptanalysis. We provide the algorithm and an example to illustrate our attack, demonstrating that this key exchange protocol is not secure. Additionally, we examine how different parameter selections and matrix sizes impact the protocol's security. Ultimately, this cryptanalysis enhances tropical cryptography by expanding our understanding of the security implications of modified tropical semiring-based key exchange protocols.},
  archive      = {J_IANDC},
  author       = {J. Jackson and R. Perumal},
  doi          = {10.1016/j.ic.2024.105259},
  journal      = {Information and Computation},
  month        = {3},
  pages        = {105259},
  shortjournal = {Inf. Comput.},
  title        = {An algebraic attack on the key exchange protocol based upon a modified tropical structure},
  volume       = {303},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Extending CL-reducibility on array noncomputable degrees. <em>IANDC</em>, <em>303</em>, 105258. (<a href='https://doi.org/10.1016/j.ic.2024.105258'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Given a function f , f -bounded-Turing ( f -bT-) reducibility is the Turing reducibility with use function bounded by f . In the special case where f = id + c (with id being the identity function and c a constant), this is referred to as cl-reducibility. In a work by Barmpalias, Fang, and Lewis-Pye, it was proven that there exist two left-c.e. reals such that no left-c.e. real ( id + g ) -bT-computes both of them whenever g is computable, nondecreasing, and satisfies ∑ n 2 − g ( n ) = ∞ . Moreover, such maximal pairs exist precisely within every array noncomputable degree. This result generalizes a prior result on cl-reducibility, which states that there exist two left-c.e. reals such that no left-c.e. real cl-computes both of them. An open question remained as to whether a similar extension could apply to another result on cl-reducibility, which asserts that there exists a left-c.e. real not cl-reducible to any random left-c.e. real. We answer this question affirmatively, providing a simpler proof compared to previous works. Additionally, we streamline the proof of the initial extension.},
  archive      = {J_IANDC},
  author       = {Nan Fang and Wolfgang Merkle},
  doi          = {10.1016/j.ic.2024.105258},
  journal      = {Information and Computation},
  month        = {3},
  pages        = {105258},
  shortjournal = {Inf. Comput.},
  title        = {Extending CL-reducibility on array noncomputable degrees},
  volume       = {303},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Reasoning about group responsibility for exceeding risk threshold in one-shot games. <em>IANDC</em>, <em>303</em>, 105257. (<a href='https://doi.org/10.1016/j.ic.2024.105257'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Tracing and analysing the responsibility for unsafe outcomes of actors' decisions in multi-agent settings have been studied in recent years. These studies often focus on deterministic scenarios and assume that the unsafe outcomes for which actors can be held responsible are actually realized. This paper considers a broader notion of responsibility where unsafe outcomes are not necessarily realized, but their probabilities are unacceptably high. We present a logic combining strategic, probabilistic and temporal primitives designed to express concepts such as the risk of an undesirable outcome and being responsible for exceeding a risk threshold in one-shot games. We demonstrate that the proposed logic is (weakly) complete, decidable and has an efficient model-checking procedure. Finally, we define a probabilistic notion of responsibility and study its formal properties in the proposed logic setting.},
  archive      = {J_IANDC},
  author       = {Maksim Gladyshev and Natasha Alechina and Mehdi Dastani and Dragan Doder},
  doi          = {10.1016/j.ic.2024.105257},
  journal      = {Information and Computation},
  month        = {3},
  pages        = {105257},
  shortjournal = {Inf. Comput.},
  title        = {Reasoning about group responsibility for exceeding risk threshold in one-shot games},
  volume       = {303},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Probabilistic judgment aggregation with conditional independence constraints. <em>IANDC</em>, <em>303</em>, 105256. (<a href='https://doi.org/10.1016/j.ic.2024.105256'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Probabilistic judgment aggregation is concerned with aggregating judgments about probabilities of logically related issues. It takes as input imprecise probabilistic judgments over the issues given by a group of agents and defines rules of aggregating the individual judgments into a collective opinion representative for the group. The process of aggregation can be subject to constraints, i.e., aggregation rules can be required to satisfy certain properties. We explore how probabilistic independence constraints can be represented and incorporated into the aggregation process.},
  archive      = {J_IANDC},
  author       = {Magdalena Ivanovska and Marija Slavkovik},
  doi          = {10.1016/j.ic.2024.105256},
  journal      = {Information and Computation},
  month        = {3},
  pages        = {105256},
  shortjournal = {Inf. Comput.},
  title        = {Probabilistic judgment aggregation with conditional independence constraints},
  volume       = {303},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Ltlf synthesis under environment specifications for reachability and safety properties. <em>IANDC</em>, <em>303</em>, 105255. (<a href='https://doi.org/10.1016/j.ic.2024.105255'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this paper, we study ltl f synthesis under environment specifications for arbitrary reachability and safety properties. We consider both kinds of properties for both agent tasks and environment specifications, providing a complete landscape of synthesis algorithms. For each case, we devise a specific algorithm (optimal wrt complexity of the problem) and prove its correctness. The algorithms combine common building blocks in different ways. While some cases are already studied in literature others are studied here for the first time.},
  archive      = {J_IANDC},
  author       = {Benjamin Aminof and Giuseppe De Giacomo and Antonio Di Stasio and Hugo Francon and Sasha Rubin and Shufang Zhu},
  doi          = {10.1016/j.ic.2024.105255},
  journal      = {Information and Computation},
  month        = {3},
  pages        = {105255},
  shortjournal = {Inf. Comput.},
  title        = {Ltlf synthesis under environment specifications for reachability and safety properties},
  volume       = {303},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Distributed fractional local ratio and independent set approximation. <em>IANDC</em>, <em>303</em>, 105238. (<a href='https://doi.org/10.1016/j.ic.2024.105238'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We consider the Maximum Weight Independent Set problem, with a focus on obtaining good approximations for graphs of small maximum degree Δ. We give deterministic local algorithms running in time poly ( Δ , log ⁡ n ) that come close to matching the best centralized results known and improve the previous distributed approximations by a factor of about 2. More precisely, we obtain approximations below Δ + 1 / 2 2 , and a further improvement to 8 / 5 + ε when Δ = 3 . Technically, this is achieved by leveraging the fractional local ratio technique, for a first application in a distributed setting.},
  archive      = {J_IANDC},
  author       = {Magnús M. Halldórsson and Dror Rawitz},
  doi          = {10.1016/j.ic.2024.105238},
  journal      = {Information and Computation},
  month        = {3},
  pages        = {105238},
  shortjournal = {Inf. Comput.},
  title        = {Distributed fractional local ratio and independent set approximation},
  volume       = {303},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). A parallel algorithm for counting parse trees. <em>IANDC</em>, <em>303</em>, 105237. (<a href='https://doi.org/10.1016/j.ic.2024.105237'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {A parallel algorithm for computing the number of parse trees of a given string according to a fixed context-free grammar is defined. More generally, the algorithm applies to computing the weight of a string in a weighted grammar over any semiring. The algorithm is first implemented on an arithmetic circuit of depth at most 6 ( log 2 ⁡ n ) 2 + O ( log ⁡ n ) and with O ( n 6 ) elements, where the constant factors in the big-O notation depend on the grammar. Then, the circuit is improved using fast matrix multiplication to use only O ( n 5.38 ) elements, while preserving depth O ( ( log ⁡ n ) 2 ) .},
  archive      = {J_IANDC},
  author       = {Margarita Mikhelson and Alexander Okhotin},
  doi          = {10.1016/j.ic.2024.105237},
  journal      = {Information and Computation},
  month        = {3},
  pages        = {105237},
  shortjournal = {Inf. Comput.},
  title        = {A parallel algorithm for counting parse trees},
  volume       = {303},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Special issue of PLACES 2022. <em>IANDC</em>, <em>302</em>, 105263. (<a href='https://doi.org/10.1016/j.ic.2024.105263'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  archive      = {J_IANDC},
  author       = {Marco Carbone and Nobuko Yoshida},
  doi          = {10.1016/j.ic.2024.105263},
  journal      = {Information and Computation},
  month        = {1},
  pages        = {105263},
  shortjournal = {Inf. Comput.},
  title        = {Special issue of PLACES 2022},
  volume       = {302},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Succinctness issues for LTLf and safety and cosafety fragments of LTL. <em>IANDC</em>, <em>302</em>, 105262. (<a href='https://doi.org/10.1016/j.ic.2024.105262'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Linear Temporal Logic over finite traces ( LTL f ) has proved itself to be an important and effective formalism in formal verification as well as in artificial intelligence. Pure past LTL f ( pLTL ) is the variant of LTL f featuring only past temporal modalities, and is naturally interpreted at the end of a finite trace. It is known that each property definable in LTL f is also definable in pLTL , and vice versa (they are expressively equivalent). The same goes for the safety and cosafety fragments of Linear Temporal Logic over infinite traces ( LTL ), when compared to G ( pLTL ) and F ( pLTL ) formulas, respectively, that is, pLTL formulas prefixed by a globally and an eventually modality. However, despite being extensively used in practice, to the best of our knowledge, there is no systematic study of their succinctness. Moreover, when considering (co)safety fragments of LTL devoid of binary temporal modalities, there are no known characterizations based on pLTL . In this paper, we investigate succinctness issues for LTL f and (co)safety fragments of LTL when compared with their pure past counterparts. First, we provide a pure past characterization of the (co)safety fragments of LTL devoid of binary temporal modalities. Then, we prove that the (co)safety fragments of LTL have pure past counterparts that can be exponentially more succinct. Finally, we show that the same holds for LTL f with respect to pLTL , and viceversa: LTL f and pLTL are incomparable when succinctness is concerned.},
  archive      = {J_IANDC},
  author       = {Alessandro Artale and Luca Geatti and Nicola Gigante and Andrea Mazzullo and Angelo Montanari},
  doi          = {10.1016/j.ic.2024.105262},
  journal      = {Information and Computation},
  month        = {1},
  pages        = {105262},
  shortjournal = {Inf. Comput.},
  title        = {Succinctness issues for LTLf and safety and cosafety fragments of LTL},
  volume       = {302},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Fixed-parameter algorithms for fair hitting set problems. <em>IANDC</em>, <em>302</em>, 105261. (<a href='https://doi.org/10.1016/j.ic.2024.105261'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Selection of a group of representatives satisfying certain fairness constraints, is a commonly occurring scenario. Motivated by this, we initiate a systematic algorithmic study of a fair version of Hitting Set . In the classical Hitting Set problem, the input is a universe U , a family F of subsets of U , and a non-negative integer k . The goal is to determine whether there exists a subset S ⊆ U of size k that hits (i.e., intersects) every set in F . Inspired by several recent works, we formulate a fair version of this problem, as follows. The input additionally contains a family B of subsets of U , where each subset in B can be thought of as the group of elements of the same type . We want to find a set S ⊆ U of size k that (i) hits all sets of F , and (ii) does not contain too many elements of each type. We call this problem Fair Hitting Set , and chart out its tractability boundary from both classical as well as multivariate perspective. Our results use a multitude of techniques from parameterized complexity including classical to advanced tools, such as, methods of representative sets for matroids, FO model checking, and a generalization of best known kernel for Hitting Set .},
  archive      = {J_IANDC},
  author       = {Tanmay Inamdar and Lawqueen Kanesh and Madhumita Kundu and Nidhi Purohit and Saket Saurabh},
  doi          = {10.1016/j.ic.2024.105261},
  journal      = {Information and Computation},
  month        = {1},
  pages        = {105261},
  shortjournal = {Inf. Comput.},
  title        = {Fixed-parameter algorithms for fair hitting set problems},
  volume       = {302},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Universal complexity bounds based on value iteration for stochastic mean payoff games and entropy games. <em>IANDC</em>, <em>302</em>, 105236. (<a href='https://doi.org/10.1016/j.ic.2024.105236'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We develop value iteration-based algorithms to solve in a unified manner different classes of combinatorial zero-sum games with mean-payoff type rewards. These algorithms rely on an oracle, evaluating the dynamic programming operator up to a given precision. We show that the number of calls to the oracle needed to determine exact optimal (positional) strategies is, up to a factor polynomial in the dimension, of order R / sep , where the “separation” sep is defined as the minimal difference between distinct values arising from strategies, and R is a metric estimate, involving the norm of approximate sub and super-eigenvectors of the dynamic programming operator. We illustrate this method by two applications. The first one is a new proof, leading to improved complexity estimates, of a theorem of Boros, Elbassioni, Gurvich and Makino, showing that turn-based mean-payoff games with a fixed number of random positions can be solved in pseudo-polynomial time. The second one concerns entropy games, a model introduced by Asarin, Cervelle, Degorre, Dima, Horn and Kozyakin. The rank of an entropy game is defined as the maximal rank among all the ambiguity matrices determined by strategies of the two players. We show that entropy games with a fixed rank, in their original formulation, can be solved in polynomial time, and that an extension of entropy games incorporating weights can be solved in pseudo-polynomial time under the same fixed rank condition.},
  archive      = {J_IANDC},
  author       = {Xavier Allamigeon and Stéphane Gaubert and Ricardo D. Katz and Mateusz Skomra},
  doi          = {10.1016/j.ic.2024.105236},
  journal      = {Information and Computation},
  month        = {1},
  pages        = {105236},
  shortjournal = {Inf. Comput.},
  title        = {Universal complexity bounds based on value iteration for stochastic mean payoff games and entropy games},
  volume       = {302},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Preface. <em>IANDC</em>, <em>302</em>, 105226. (<a href='https://doi.org/10.1016/j.ic.2024.105226'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {This Special Issue of Information and Computation contains selected papers from two editions (2021 and 2022) of EXPRESS/SOS, the Combined International Workshop on Expressiveness in Concurrency (EXPRESS) and Structural Operational Semantics (SOS), which is held every year in affiliation with CONCUR (the International Conference on Concurrency Theory). The aim of this Special Issue is to highlight the best contributions presented at the two editions of the workshop, in order to make them more accessible to the researchers interested in the formal semantics of systems and programming concepts, and in the expressiveness of computational models.},
  archive      = {J_IANDC},
  author       = {Valentina Castiglioni and Ornela Dardha and Claudio Antares Mezzina},
  doi          = {10.1016/j.ic.2024.105226},
  journal      = {Information and Computation},
  month        = {1},
  pages        = {105226},
  shortjournal = {Inf. Comput.},
  title        = {Preface},
  volume       = {302},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Preface to “Computation over compressed data” at DCC 2022. <em>IANDC</em>, <em>302</em>, 105165. (<a href='https://doi.org/10.1016/j.ic.2024.105165'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  archive      = {J_IANDC},
  author       = {Travis Gagie and Nicola Prezza},
  doi          = {10.1016/j.ic.2024.105165},
  journal      = {Information and Computation},
  month        = {1},
  pages        = {105165},
  shortjournal = {Inf. Comput.},
  title        = {Preface to “Computation over compressed data” at DCC 2022},
  volume       = {302},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Preface to special issue: EXPRESS/SOS 2019 and EXPRESS/SOS 2020. <em>IANDC</em>, <em>302</em>, 105154. (<a href='https://doi.org/10.1016/j.ic.2024.105154'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  archive      = {J_IANDC},
  author       = {Ornela Dardha and Jorge A. Pérez and Jurriaan Rot},
  doi          = {10.1016/j.ic.2024.105154},
  journal      = {Information and Computation},
  month        = {1},
  pages        = {105154},
  shortjournal = {Inf. Comput.},
  title        = {Preface to special issue: EXPRESS/SOS 2019 and EXPRESS/SOS 2020},
  volume       = {302},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Preface: Selected papers from SSS'2019, the 21st international symposium on stabilization, safety, and security of distributed systems. <em>IANDC</em>, <em>302</em>, 105034. (<a href='https://doi.org/10.1016/j.ic.2023.105034'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  archive      = {J_IANDC},
  author       = {Mikhail Nesterenko and Sébastien Tixeuil and Sara Tucci and Yukiko Yamauchi},
  doi          = {10.1016/j.ic.2023.105034},
  journal      = {Information and Computation},
  month        = {1},
  pages        = {105034},
  shortjournal = {Inf. Comput.},
  title        = {Preface: Selected papers from SSS'2019, the 21st international symposium on stabilization, safety, and security of distributed systems},
  volume       = {302},
  year         = {2025},
}
</textarea>
</details></li>
</ul>

</body>
</html>
