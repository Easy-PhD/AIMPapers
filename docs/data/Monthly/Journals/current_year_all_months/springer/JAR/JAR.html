<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>JAR</title>
  <style>
    html {font-size: 22px;}
    body {margin: 0 auto; max-width: 76em;}
    #copyID {font-size: 18px;}
  </style>
  <script>
    function copy(element) {
      if (element.type == "button"){
      element.type="text";
      }
      element.style.color="black";
      element.style.backgroundColor="#C7EDCC";
      element.select();
      element.setSelectionRange(0, 99999);
      navigator.clipboard.writeText(element.value);
      window.getSelection().removeAllRanges();
      element.type="button";
    }
  </script>
</head>
<body>

<h2 id="jar">JAR - 29</h2>
<ul>
<li><details>
<summary>
(2025). First-order hybrid separation logic. <em>JAR</em>, <em>69</em>(4), 1-13. (<a href='https://doi.org/10.1007/s10817-025-09739-4'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The basic set-theoretic interpretation of the separating connectives of first-order separation logic allows for an effective, sound and complete axiomatization in a hybrid extension.},
  archive      = {J_JAR},
  author       = {Boer, Frank S. de and Hiep, Hans-Dieter A.},
  doi          = {10.1007/s10817-025-09739-4},
  journal      = {Journal of Automated Reasoning},
  month        = {12},
  number       = {4},
  pages        = {1-13},
  shortjournal = {J. Auto. Reasoning},
  title        = {First-order hybrid separation logic},
  volume       = {69},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). A simple proof of correctness of folding the regular heptagon. <em>JAR</em>, <em>69</em>(4), 1-9. (<a href='https://doi.org/10.1007/s10817-025-09740-x'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We give a simple proof of correctness of folding the regular heptagon with origami. Our proof avoids using complex geometry, only polynomials and basic algebraic geometry is required with simple rigidity considerations. We also exploit automated reasoning via efficient black-box computing of Gröbner bases. Our proof can be used in classrooms where learners are not familiar with complex numbers.},
  archive      = {J_JAR},
  author       = {Kovács, Zoltán},
  doi          = {10.1007/s10817-025-09740-x},
  journal      = {Journal of Automated Reasoning},
  month        = {12},
  number       = {4},
  pages        = {1-9},
  shortjournal = {J. Auto. Reasoning},
  title        = {A simple proof of correctness of folding the regular heptagon},
  volume       = {69},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Formalization of convergence rates of four first-order algorithms for convex optimization. <em>JAR</em>, <em>69</em>(4), 1-25. (<a href='https://doi.org/10.1007/s10817-025-09741-w'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The convergence rate of various first-order optimization algorithms is a pivotal concern within the numerical optimization community, as it directly reflects the efficiency of these algorithms across different optimization problems. Our goal is to make a significant step forward in the formal mathematical representation of optimization techniques using the Lean4 theorem prover. We first formalize the gradient for smooth functions and the subgradient for convex functions on a Hilbert space, laying the groundwork for the accurate formalization of algorithmic structures. Then, we extend our contribution by proving several properties of differentiable convex functions that have not yet been formalized in Lean’s mathematical library Mathlib. Finally, a comprehensive formalization of these algorithms is presented. These developments are not only noteworthy on their own but also serve as essential precursors to the formalization of a broader spectrum of numerical algorithms and their applications in machine learning as well as many other areas.},
  archive      = {J_JAR},
  author       = {Li, Chenyi and Wang, Ziyu and He, Wanyi and Wu, Yuxuan and Xu, Shengyang and Wen, Zaiwen},
  doi          = {10.1007/s10817-025-09741-w},
  journal      = {Journal of Automated Reasoning},
  month        = {12},
  number       = {4},
  pages        = {1-25},
  shortjournal = {J. Auto. Reasoning},
  title        = {Formalization of convergence rates of four first-order algorithms for convex optimization},
  volume       = {69},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Theorem proving as constraint solving for coherent logic with function symbols. <em>JAR</em>, <em>69</em>(4), 1-37. (<a href='https://doi.org/10.1007/s10817-025-09742-9'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We present an automated prover for coherent logic with function symbols which uses the power of SMT solvers through the recently proposed paradigm “theorem proving as constraint solving”. The open-source implementation of the prover supports export of proofs in natural language and to the proof assistants Coq, Isabelle, and Mizar, and has other additional features such as the support for completing premises, goals, partially given proofs, and the support for creating illustrated proofs.},
  archive      = {J_JAR},
  author       = {Janičić, Predrag},
  doi          = {10.1007/s10817-025-09742-9},
  journal      = {Journal of Automated Reasoning},
  month        = {12},
  number       = {4},
  pages        = {1-37},
  shortjournal = {J. Auto. Reasoning},
  title        = {Theorem proving as constraint solving for coherent logic with function symbols},
  volume       = {69},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Constructing the lie algebra of smooth vector fields on a lie group in Isabelle/HOL. <em>JAR</em>, <em>69</em>(3), 1-29. (<a href='https://doi.org/10.1007/s10817-025-09724-x'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {This paper describes a formal theory of smooth vector fields, Lie groups and the Lie algebra of a Lie group in the theorem prover Isabelle. Lie groups are abstract structures that are composable, invertible and differentiable; they are useful in the study of continuous transformations in fields such as particle physics and robotics. The formalisation of this theory in an interactive theorem prover poses challenges beyond those encountered in textbook developments. We comment on representational choices we made to integrate involved concepts, such as smoothness of vector fields, with the simple type theory of higher-order logic (HOL) and existing material in Isabelle/HOL.},
  archive      = {J_JAR},
  author       = {Schmoetten, Richard and Fleuriot, Jacques D.},
  doi          = {10.1007/s10817-025-09724-x},
  journal      = {Journal of Automated Reasoning},
  month        = {9},
  number       = {3},
  pages        = {1-29},
  shortjournal = {J. Auto. Reasoning},
  title        = {Constructing the lie algebra of smooth vector fields on a lie group in Isabelle/HOL},
  volume       = {69},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Active learning for SAT solver benchmarking. <em>JAR</em>, <em>69</em>(3), 1-23. (<a href='https://doi.org/10.1007/s10817-025-09729-6'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Benchmarking is crucial for developing new algorithms. This also applies to solvers for the propositional satisfiability (SAT) problem. Benchmark selection is about choosing representative problem instances that reliably discriminate solvers based on their runtime. In this paper, we present a dynamic benchmark selection approach based on active learning. Our approach estimates the rank of a new solver among its competitors, striving to minimize benchmarking runtime but maximize ranking accuracy. Instead of using real-valued solver runtimes, our approach works with discretized runtime labels, which yielded better solver rank predictions. We evaluated this approach on the Anniversary Track dataset from the SAT Competition 2022. Our benchmark selection approach can predict the rank of a new solver after approximately 10 % of the time it would take to run the solver on all instances of this dataset, with a prediction accuracy of approximately 92 %. Additionally, we discuss the importance of instance families in the selection process. In conclusion, our tool offers a reliable method for solver engineers to assess a new solver’s performance efficiently.},
  archive      = {J_JAR},
  author       = {Fuchs, Tobias and Bach, Jakob and Iser, Markus},
  doi          = {10.1007/s10817-025-09729-6},
  journal      = {Journal of Automated Reasoning},
  month        = {9},
  number       = {3},
  pages        = {1-23},
  shortjournal = {J. Auto. Reasoning},
  title        = {Active learning for SAT solver benchmarking},
  volume       = {69},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Double auctions: Formalization and automated checkers. <em>JAR</em>, <em>69</em>(3), 1-33. (<a href='https://doi.org/10.1007/s10817-025-09732-x'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Double auctions are widely used in financial markets, such as those for stocks, derivatives, currencies, and commodities, to match demand and supply. Once all buyers and sellers have placed their trade requests, the exchange determines how these requests are to be matched. The two most common objectives for determining the matching are maximizing trade volume at a uniform price and maximizing trade volume through dynamic pricing. In this work, we present fully formalized matching algorithms for double auctions, along with their correctness proofs. We establish new uniqueness theorems, enabling automatic detection of violations in exchange systems by comparing their output to that of a verified program. All proofs are formalized in the Coq Proof Assistant; we extract verified OCaml and Haskell programs that could serve as a resource for exchanges and market regulators. We demonstrate the practical applicability of our work by running the verified program on real market data from an exchange to automatically check for violations in the exchange algorithm.},
  archive      = {J_JAR},
  author       = {Garg, Mohit and Raja, N. and Sarswat, Suneel and Singh, Abhishek Kr},
  doi          = {10.1007/s10817-025-09732-x},
  journal      = {Journal of Automated Reasoning},
  month        = {9},
  number       = {3},
  pages        = {1-33},
  shortjournal = {J. Auto. Reasoning},
  title        = {Double auctions: Formalization and automated checkers},
  volume       = {69},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Automated reasoning for proving non-orderability of groups. <em>JAR</em>, <em>69</em>(3), 1-32. (<a href='https://doi.org/10.1007/s10817-025-09734-9'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We demonstrate how a generic automated theorem prover can be applied to establish the non-orderability of groups. Our approach incorporates various tools such as reasoning from the first principles, positive cones, torsions, generalised torsions and cofinal elements.},
  archive      = {J_JAR},
  author       = {Lisitsa, Alexei and Nie, Zipei and Vernitski, Alexei},
  doi          = {10.1007/s10817-025-09734-9},
  journal      = {Journal of Automated Reasoning},
  month        = {9},
  number       = {3},
  pages        = {1-32},
  shortjournal = {J. Auto. Reasoning},
  title        = {Automated reasoning for proving non-orderability of groups},
  volume       = {69},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Solving a problem with GeoGebra current possibilities and limits of CAS tools. <em>JAR</em>, <em>69</em>(3), 1-13. (<a href='https://doi.org/10.1007/s10817-025-09733-w'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In the article we show what a Dynamic Geometry Environment (DGE) and Computer Algebra System (CAS) software is capable of exploring, computing and proving a geometry problem that is closely related to the well-known Wallace-Simson theorem. In our case, this problem turns out to be quite difficult for some software tools incorporated in the DGE software. The computation of a searched locus by the software works well in our case, but the problem must be formulated in a specific way. In addition to the conclusions attained by DGE software, we present computer-aided analytical solutions in the second half of paper. It is shown that the use of non-degeneracy conditions before elimination leads to a significant reduction of the computation time.},
  archive      = {J_JAR},
  author       = {Blažek, Jiří and Pech, Pavel},
  doi          = {10.1007/s10817-025-09733-w},
  journal      = {Journal of Automated Reasoning},
  month        = {9},
  number       = {3},
  pages        = {1-13},
  shortjournal = {J. Auto. Reasoning},
  title        = {Solving a problem with GeoGebra current possibilities and limits of CAS tools},
  volume       = {69},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Formally verified suffix array construction. <em>JAR</em>, <em>69</em>(3), 1-38. (<a href='https://doi.org/10.1007/s10817-025-09735-8'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Suffix arrays are a data structure with numerous real-world applications. They are extensively used in text retrieval and data compression applications, including query suggestion mechanisms in web search, and in bioinformatics tools for DNA sequencing and matching. This wide applicability means that algorithms for constructing suffix arrays are of great practical importance. The SA-IS algorithm is an efficient but conceptually complex suffix array construction technique, and implementing it requires a deep understanding of its underlying theory. As a critical step towards developing a provably correct and efficient implementation, we have developed the SA-IS algorithm in Isabelle/HOL and formally verified that it is equivalent to a mathematical functional specification of suffix arrays, a task that required verifying a wide range of underlying properties of strings and suffixes. We also used Isabelle’s code extraction facilities to extract an executable Haskell implementation of SA-IS, which albeit is inefficient due to using lists and natural numbers rather than arrays and machine words, demonstrates that our verified HOL implementation of SA-IS can be refined to an executable implementation in its current form.},
  archive      = {J_JAR},
  author       = {Cheung, Louis and Moffat, Alistair and Rizkallah, Christine},
  doi          = {10.1007/s10817-025-09735-8},
  journal      = {Journal of Automated Reasoning},
  month        = {9},
  number       = {3},
  pages        = {1-38},
  shortjournal = {J. Auto. Reasoning},
  title        = {Formally verified suffix array construction},
  volume       = {69},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Structured monads for generic first-order syntax metatheory. <em>JAR</em>, <em>69</em>(3), 1-41. (<a href='https://doi.org/10.1007/s10817-025-09731-y'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Reasoning about substitution remains one of the most tedious and error-prone aspects of formal metatheory. We present Tealeaves, a framework implemented in Coq for developing such infrastructure generically and modularly. Tealeaves is centered on a novel categorical abstraction, decorated traversable monads (DTMs), which provide a unifying foundation for first-order syntax and enable local, compositional reasoning about syntactic operations, such as substitution, that are defined purely by their effect on individual variable occurrences. Within this framework, Tealeaves supports extensible backend modules, each implementing the metatheory of a specific concrete strategy for representing binders. Our current backends include implementations of de Bruijn indices in the style of Autosubst, as well as locally nameless in the style of LNgen. Tealeaves goes further by providing a certified translation between these representations, illustrating how DTMs reconcile their underlying structures. The framework also accommodates challenging features such as variadic and mutually-recursive binders, which are often overlooked by both theoretical treatments and practical tools. We describe the implementation and use of Tealeaves’ backends in formalized language developments, introduce the equational axioms that characterize DTMs, and conclude with a presentation of those axioms instantiated for the lambda calculus extended with a variadic binding constructor.},
  archive      = {J_JAR},
  author       = {Dunn, Lawrence and Tannen, Val and Zdancewic, Steve},
  doi          = {10.1007/s10817-025-09731-y},
  journal      = {Journal of Automated Reasoning},
  month        = {9},
  number       = {3},
  pages        = {1-41},
  shortjournal = {J. Auto. Reasoning},
  title        = {Structured monads for generic first-order syntax metatheory},
  volume       = {69},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Reasoning about incompletely defined programs. <em>JAR</em>, <em>69</em>(3), 1-48. (<a href='https://doi.org/10.1007/s10817-025-09722-z'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We consider automated reasoning about recursively defined partial functions with decidable domain, i.e. functions computed by incompletely defined (or underspecified) but terminating functional programs. We define an interpreter for those programs, consider termination and investigate the semantics of incompletely defined programs. The interpreter may halt with a stuck computation, e.g. when dividing a number by zero, which represents a runtime error in a conventional programming environment. We show how so-called domain procedures are synthesized which decide the domain of incompletely defined procedures in almost all cases. As calls of domain procedures occur in proof obligations, domain procedures are optimized to make them as simple as possible. We also use domain procedures to refine the program semantics such that statements causing stuck computations do not hold. Our method to reason about incompletely defined programs is implemented in the verification tool VeriFun.},
  archive      = {J_JAR},
  author       = {Walther, Christoph},
  doi          = {10.1007/s10817-025-09722-z},
  journal      = {Journal of Automated Reasoning},
  month        = {9},
  number       = {3},
  pages        = {1-48},
  shortjournal = {J. Auto. Reasoning},
  title        = {Reasoning about incompletely defined programs},
  volume       = {69},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Computing expected visiting times and stationary distributions in markov chains: Fast and accurate. <em>JAR</em>, <em>69</em>(3), 1-50. (<a href='https://doi.org/10.1007/s10817-025-09736-7'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We study the accurate and efficient computation of the expected number of times each state is visited in discrete- and continuous-time Markov chains. To obtain sound accuracy guarantees efficiently, we lift interval iteration, optimistic value iteration and topological approaches developed to compute reachability probabilities and expected rewards and prove all these algorithms to be correct. We further establish that expected visiting times are preserved under backward probabilistic bisimilarity. We study various applications of expected visiting times. The reachability probabilities of multiple bottom strongly connected components (BSCCs) can be obtained by solving a single linear equation system—as opposed to solving an equation system per BSCC. Other applications include the sound computation of the stationary distribution as well as expected rewards conditioned on reaching multiple goal states. The implementation of our methods in the probabilistic model checker Storm scales to large systems with millions of states. Our experiments on the quantitative verification benchmark set show that the computation of stationary distributions via expected visiting times consistently outperforms existing approaches—sometimes by several orders of magnitude.},
  archive      = {J_JAR},
  author       = {Mertens, Hannah and Katoen, Joost-Pieter and Quatmann, Tim and Winkler, Tobias},
  doi          = {10.1007/s10817-025-09736-7},
  journal      = {Journal of Automated Reasoning},
  month        = {9},
  number       = {3},
  pages        = {1-50},
  shortjournal = {J. Auto. Reasoning},
  title        = {Computing expected visiting times and stationary distributions in markov chains: Fast and accurate},
  volume       = {69},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). LTL reactive synthesis with a few hints. <em>JAR</em>, <em>69</em>(3), 1-50. (<a href='https://doi.org/10.1007/s10817-025-09737-6'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We study a variant of the problem of synthesizing Mealy machines that enforce LTL specifications against all possible behaviours of the environment including hostile ones. In the variant studied here, the user provides the high level LTL specification $$\varphi $$ of the system to design, and a set E of examples of executions that the solution must produce. Our synthesis algorithm works in two phases. First, it generalizes the decisions taken along the examples E using tailored extensions of automata learning algorithms. This phase generalizes the user-provided examples in E while preserving realizability of $$\varphi $$ . Second, the algorithm turns the (usually) incomplete Mealy machine obtained by the learning phase into a complete Mealy machine that realizes $$\varphi $$ . The examples are used to guide the synthesis procedure. We provide a completeness result that shows that our procedure can learn any Mealy machine M that realizes $$\varphi $$ with a small (polynomial) set of examples. We also show that our problem, that generalizes the classical LTL synthesis problem (i.e. when $$E=\emptyset $$ ), matches its worst-case complexity. The additional cost of learning from E is even polynomial in the size of E and in the size of a symbolic representation of solutions that realize $$\varphi $$ . This symbolic representation is computed by the synthesis algorithm implemented in Acacia-Bonzai when solving the plain LTL synthesis problem. We illustrate the practical interest of our approach on a set of examples.},
  archive      = {J_JAR},
  author       = {Balachander, Mrudula and Filiot, Emmanuel and Raskin, Jean-François},
  doi          = {10.1007/s10817-025-09737-6},
  journal      = {Journal of Automated Reasoning},
  month        = {9},
  number       = {3},
  pages        = {1-50},
  shortjournal = {J. Auto. Reasoning},
  title        = {LTL reactive synthesis with a few hints},
  volume       = {69},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). A proof-producing compiler for blockchain applications. <em>JAR</em>, <em>69</em>(2), 1-25. (<a href='https://doi.org/10.1007/s10817-025-09723-y'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {CairoZero is a programming language for running decentralized applications (dApps) at scale. Programs written in the CairoZero language are compiled to machine code for the Cairo CPU architecture and cryptographic protocols are used to verify the results of execution efficiently on blockchain. We explain how we have extended the CairoZero compiler with tooling that enables users to prove, in the Lean 3 proof assistant, that compiled code satisfies high-level functional specifications. We demonstrate the success of our approach by verifying primitives for computation with the secp256k1 and secp256r1 curves over a large finite field as well as the validation of cryptographic signatures using the former. We also verify a mechanism for simulating a read-write dictionary data structure in a read-only setting. Finally, we reflect on our methodology and discuss some of the benefits of our approach.},
  archive      = {J_JAR},
  author       = {Avigad, Jeremy and Goldberg, Lior and Levit, David and Seginer, Yoav and Titelman, Alon},
  doi          = {10.1007/s10817-025-09723-y},
  journal      = {Journal of Automated Reasoning},
  month        = {6},
  number       = {2},
  pages        = {1-25},
  shortjournal = {J. Auto. Reasoning},
  title        = {A proof-producing compiler for blockchain applications},
  volume       = {69},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). A direct procedure to test entailment in a separation logic of relations. <em>JAR</em>, <em>69</em>(2), 1-38. (<a href='https://doi.org/10.1007/s10817-025-09728-7'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We devise a direct decision procedure to test entailment in a separation logic of relations, which generalizes standard separation logic by considering structures defined over arbitrary relations. The logic allows for user-defined predicate symbols, describing structures of unbounded size, with a fixpoint semantics. We show that the entailment problem is 2-ExpTime complete if the rules defining the semantics of these predicates satisfy some conditions, which generalize the PCE conditions of Iosif et al. (in: Proceedings of CADE-24, Volume 7898 of LNCS, 2013).},
  archive      = {J_JAR},
  author       = {Echenim, Mnacho and Peltier, Nicolas},
  doi          = {10.1007/s10817-025-09728-7},
  journal      = {Journal of Automated Reasoning},
  month        = {6},
  number       = {2},
  pages        = {1-38},
  shortjournal = {J. Auto. Reasoning},
  title        = {A direct procedure to test entailment in a separation logic of relations},
  volume       = {69},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). A mechanically verified garbage collector for OCaml. <em>JAR</em>, <em>69</em>(2), 1-43. (<a href='https://doi.org/10.1007/s10817-025-09721-0'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The OCaml programming language finds application across diverse domains, including systems programming, web development, scientific computing, formal verification, and symbolic mathematics. OCaml is a memory-safe programming language that uses a garbage collector (GC) to free unreachable memory. It features a low-latency, high-performance GC, tuned for functional programming. The GC has two generations—a minor heap collected using a copying collector and a major heap collected using an incremental mark-and-sweep collector. Alongside the intricacies of an efficient GC design, OCaml compiler uses efficient object representations for some object classes, such as interior pointers for supporting mutually recursive functions, which further complicates the GC design. The GC is a critical component of the OCaml runtime system, and its correctness is essential for the safety of OCaml programs. In this paper, we propose a strategy for crafting a correct, proof-oriented GC from scratch, designed to evolve over time with additional language features. Our approach neatly separates abstract GC correctness from OCaml-specific GC correctness, offering the ability to integrate further GC optimizations, while preserving core abstract GC correctness. As an initial step to demonstrate the viability of our approach, we have developed a verified stop-the-world mark-and-sweep GC for OCaml. The approach is fully mechanized in F* and its low-level subset Low*. We use the KaRaMel compiler to compile Low* to C, and integrate the verified GC with the OCaml runtime. Our GC is evaluated against off-the-shelf OCaml GC and Boehm–Demers–Weiser conservative GC, and the experimental results show that verified OCaml GC is competitive with the standard OCaml GC.},
  archive      = {J_JAR},
  author       = {Shamsu, Sheera and Kafle, Dipesh and Maroo, Dhruv and Nagar, Kartik and Bhargavan, Karthikeyan and Sivaramakrishnan, KC},
  doi          = {10.1007/s10817-025-09721-0},
  journal      = {Journal of Automated Reasoning},
  month        = {6},
  number       = {2},
  pages        = {1-43},
  shortjournal = {J. Auto. Reasoning},
  title        = {A mechanically verified garbage collector for OCaml},
  volume       = {69},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Producing proofs of unsatisfiability with distributed clause-sharing SAT solvers. <em>JAR</em>, <em>69</em>(2), 1-26. (<a href='https://doi.org/10.1007/s10817-025-09725-w'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Distributed clause-sharing SAT solvers can solve challenging problems hundreds of times faster than sequential SAT solvers by sharing derived information among multiple sequential solvers. Unlike sequential solvers, however, distributed solvers have not been able to produce proofs of unsatisfiability in a scalable manner, which limits their use in critical applications. In this work, we present a method to produce unsatisfiability proofs for distributed SAT solvers by combining the partial proofs produced by each sequential solver into a single, linear proof. We first describe a simple sequential algorithm and then present a fully distributed algorithm for proof composition, which is substantially more scalable and general than prior works. Our empirical evaluation with over 1500 solver threads shows that our distributed approach allows proof composition and checking within around 3 $$\times $$ its own (highly competitive) solving time.},
  archive      = {J_JAR},
  author       = {Michaelson, Dawn and Schreiber, Dominik and Heule, Marijn J. H. and Kiesl-Reiter, Benjamin and Whalen, Michael W.},
  doi          = {10.1007/s10817-025-09725-w},
  journal      = {Journal of Automated Reasoning},
  month        = {6},
  number       = {2},
  pages        = {1-26},
  shortjournal = {J. Auto. Reasoning},
  title        = {Producing proofs of unsatisfiability with distributed clause-sharing SAT solvers},
  volume       = {69},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). A sound and complete projection for global types. <em>JAR</em>, <em>69</em>(2), 1-33. (<a href='https://doi.org/10.1007/s10817-025-09726-9'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Multiparty session types is a typing discipline used to write specifications, known as global types, for branching and recursive message-passing systems. A necessary operation on global types is projection to abstractions of local behaviour, called local types. Typically, this is a computable partial function that given a global type and a role erases all details irrelevant to this role. Computable projection functions in the literature are either unsound or too restrictive when dealing with recursion and branching. Recent work has taken a more general approach to projection defining it as a coinductive, but not computable, relation. Our work defines a new computable projection function that is sound and complete with respect to its coinductive counterpart and, hence, equally expressive. All results have been mechanised in the Coq proof assistant.},
  archive      = {J_JAR},
  author       = {Tirore, Dawit and Bengtson, Jesper and Carbone, Marco},
  doi          = {10.1007/s10817-025-09726-9},
  journal      = {Journal of Automated Reasoning},
  month        = {6},
  number       = {2},
  pages        = {1-33},
  shortjournal = {J. Auto. Reasoning},
  title        = {A sound and complete projection for global types},
  volume       = {69},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). The QSMA algorithm for quantifiers in SMT. <em>JAR</em>, <em>69</em>(2), 1-40. (<a href='https://doi.org/10.1007/s10817-025-09727-8'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Deciding the satisfiability of formulas involving both quantifiers and theory defined symbols is a challenge in automated reasoning. This article presents an algorithm, called $$\textsf{QSMA}$$ (Quantified Satisfiability Modulo Assignment), for the satisfiability of an arbitrary quantified formula modulo a complete theory and an initial assignment. The algorithm is proved partially correct and terminating, so that its total correctness is established. An optimized variant called $$\textsf{OptiQSMA}$$ is also described and shown to preserve both partial correctness and termination. $$\textsf{OptiQSMA}$$ is implemented in the YicesQS solver. $$\textsf{OptiQSMA}$$ enabled YicesQS to achieve top of the line results, especially in linear rational arithmetic, in the 2022, 2023, and 2024 editions of the International Satisfiability Modulo Theories Competition (SMT-COMP). A report on these results in four fragments of arithmetic ( $$\textsf{LRA}$$ —Linear Rational Arithmetic, $$\textsf{LIA}$$ —Linear Integer Arithmetic, $$\textsf{NRA}$$ —Nonlinear Real Arithmetic, and $$\textsf{NIA}$$ —Nonlinear Integer Arithmetic) and in the theory of bitvectors ( $$\textsf{BV}$$ ) is included.},
  archive      = {J_JAR},
  author       = {Bonacina, Maria Paola and Graham-Lengrand, Stéphane and Vauthier, Christophe},
  doi          = {10.1007/s10817-025-09727-8},
  journal      = {Journal of Automated Reasoning},
  month        = {6},
  number       = {2},
  pages        = {1-40},
  shortjournal = {J. Auto. Reasoning},
  title        = {The QSMA algorithm for quantifiers in SMT},
  volume       = {69},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Timed automata verification and synthesis via finite automata learning. <em>JAR</em>, <em>69</em>(2), 1-27. (<a href='https://doi.org/10.1007/s10817-025-09730-z'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We present algorithms formodel checking and controller synthesis of timed automata, seeing a timed automaton model as a parallel composition of a large finite-state machine and a relatively smaller timed automaton, and using compositional reasoning on this composition. We use automata learning algorithms to learn finite automata approximations of the timed automaton component, in order to reduce the problem at hand to finite-state model checking or to finite-state controller synthesis.We present an experimental evaluation of our approach.},
  archive      = {J_JAR},
  author       = {Sankur, Ocan},
  doi          = {10.1007/s10817-025-09730-z},
  journal      = {Journal of Automated Reasoning},
  month        = {6},
  number       = {2},
  pages        = {1-27},
  shortjournal = {J. Auto. Reasoning},
  title        = {Timed automata verification and synthesis via finite automata learning},
  volume       = {69},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Use and abuse of instance parameters in the lean mathematical library. <em>JAR</em>, <em>69</em>(1), 1-30. (<a href='https://doi.org/10.1007/s10817-024-09712-7'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The Lean mathematical library Mathlib features extensive use of the typeclass pattern for organising mathematical structures, based on Lean’s mechanism of instance parameters. Related mechanisms for typeclasses are available in other provers including Agda, Coq and Isabelle with varying degrees of adoption. This paper analyses representative examples of design patterns involving instance parameters in the finalized Lean 3 version of Mathlib, focussing on complications arising at scale and how the Mathlib community deals with them.},
  archive      = {J_JAR},
  author       = {Baanen, Anne},
  doi          = {10.1007/s10817-024-09712-7},
  journal      = {Journal of Automated Reasoning},
  month        = {3},
  number       = {1},
  pages        = {1-30},
  shortjournal = {J. Auto. Reasoning},
  title        = {Use and abuse of instance parameters in the lean mathematical library},
  volume       = {69},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Interpolation and SAT-based model checking revisited: Adoption to software verification. <em>JAR</em>, <em>69</em>(1), 1-29. (<a href='https://doi.org/10.1007/s10817-024-09702-9'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The article Interpolation and SAT-Based Model Checking (McMillan in: Proc. CAV 2003, LNCS, Springer [56]) describes a formal-verification algorithm, which was originally devised to verify safety properties of finite-state transition systems. It derives interpolants from unsatisfiable BMC queries and collects them to construct an overapproximation of the set of reachable states. Although 20 years old, the algorithm is still state-of-the-art in hardware model checking. Unlike other formal-verification algorithms, such as or PDR, which have been extended to handle infinite-state systems and investigated for program analysis, McMillan’s interpolation-based model-checking algorithm from 2003 has not been used to verify programs so far. Our contribution is to close this significant, two decades old gap in knowledge by adopting the algorithm to software verification. We implemented it in the verification framework CPAchecker and evaluated the implementation against other state-of-the-art software-verification techniques on the largest publicly available benchmark suite of C safety-verification tasks. The evaluation demonstrates that McMillan’s interpolation-based model-checking algorithm from 2003 is competitive among other algorithms in terms of both the number of solved verification tasks and the run-time efficiency. Our results are important for the area of software verification, because researchers and developers now have one more approach to choose from.},
  archive      = {J_JAR},
  author       = {Beyer, Dirk and Lee, Nian-Ze and Wendler, Philipp},
  doi          = {10.1007/s10817-024-09702-9},
  journal      = {Journal of Automated Reasoning},
  month        = {3},
  number       = {1},
  pages        = {1-29},
  shortjournal = {J. Auto. Reasoning},
  title        = {Interpolation and SAT-based model checking revisited: Adoption to software verification},
  volume       = {69},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Satisfiability of non-linear transcendental arithmetic as a certificate search problem. <em>JAR</em>, <em>69</em>(1), 1-35. (<a href='https://doi.org/10.1007/s10817-024-09716-3'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {For typical first-order logical theories, satisfying assignments have a straightforward finite representation that can directly serve as a certificate that a given assignment satisfies the given formula. For non-linear real arithmetic augmented with trigonometric and exponential functions ( $$\mathcal {N\hspace{-0.55542pt}T\hspace{-2.22214pt}A}$$ ), however, there is no known direct representation of satisfying assignments that allows for a simple independent check of whether the represented numbers exist and satisfy the given formula. Hence, in this paper, we introduce a different form of satisfiability certificate for $$\mathcal {N\hspace{-0.55542pt}T\hspace{-2.22214pt}A}$$ , and formulate the satisfiability problem as the problem of searching for such a certificate. This does not only ease the independent verification of satisfiability, but also allows the design of new algorithms that show satisfiability by systematically searching for such certificates. Computational experiments document that the resulting algorithms are able to prove satisfiability of a substantially higher number of benchmark problems than existing methods. We also characterize the formulas whose satisfiability can be demonstrated by such a certificate, by providing lower and upper bounds in terms of relevant well-known classes. Finally we show the existence of a procedure for checking the satisfiability of $$\mathcal {N\hspace{-0.55542pt}T\hspace{-2.22214pt}A}$$ -formulas that terminates for formulas that satisfy certain robustness assumptions.},
  archive      = {J_JAR},
  author       = {Lipparini, Enrico and Ratschan, Stefan},
  doi          = {10.1007/s10817-024-09716-3},
  journal      = {Journal of Automated Reasoning},
  month        = {3},
  number       = {1},
  pages        = {1-35},
  shortjournal = {J. Auto. Reasoning},
  title        = {Satisfiability of non-linear transcendental arithmetic as a certificate search problem},
  volume       = {69},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Computer-assisted proofs for lyapunov stability via sums of squares certificates and constructive analysis. <em>JAR</em>, <em>69</em>(1), 1-33. (<a href='https://doi.org/10.1007/s10817-024-09717-2'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We provide a computer-assisted approach to ensure that a given discrete-time polynomial system is (asymptotically) stable. Our framework relies on constructive analysis together with formally certified sums of squares Lyapunov functions. The crucial steps are formalized within the proof assistant $$\texttt {Minlog}$$ . We illustrate our approach with an example issued from the control system literature.},
  archive      = {J_JAR},
  author       = {Devadze, Grigory and Magron, Victor and Streif, Stefan},
  doi          = {10.1007/s10817-024-09717-2},
  journal      = {Journal of Automated Reasoning},
  month        = {3},
  number       = {1},
  pages        = {1-33},
  shortjournal = {J. Auto. Reasoning},
  title        = {Computer-assisted proofs for lyapunov stability via sums of squares certificates and constructive analysis},
  volume       = {69},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Formalization of the prime number theorem with a remainder term. <em>JAR</em>, <em>69</em>(1), 1-23. (<a href='https://doi.org/10.1007/s10817-025-09718-9'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {This paper describes the formalization of the prime number theorem with a remainder term in the Isabelle/HOL proof assistant. First, we formalized several lemmas in complex analysis that were not available in the library, such as the Borel–Carathéodory theorem and the factorization of an analytic function on a compact region. Then, we use these results to formalize a zero-free region of the Riemann zeta function with an explicitly computed constant and deduce the asymptotic growth order of $$\zeta '(s) / \zeta (s)$$ near $$\textrm{Re}(s) = 1$$ . Finally, using a specific form of Perron’s formula, we prove the prime number theorem with the classical remainder term, expressed in terms of $$\psi (x)$$ . We also formalized the result that the prime number theorem stated using $$\psi (x)$$ can imply the version stated using $$\pi (x)$$ . Thus, we can achieve the main result of this paper. Our work extensively utilizes the rich libraries of complex analysis and asymptotic analysis in Isabelle/HOL, including concepts such as the winding number, the residue theorem, and proof automation tools such as the tactic. This is why we chose Isabelle to formalize analytic number theory instead of using other interactive provers.},
  archive      = {J_JAR},
  author       = {Song, Shuhao and Yao, Bowen},
  doi          = {10.1007/s10817-025-09718-9},
  journal      = {Journal of Automated Reasoning},
  month        = {3},
  number       = {1},
  pages        = {1-23},
  shortjournal = {J. Auto. Reasoning},
  title        = {Formalization of the prime number theorem with a remainder term},
  volume       = {69},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Correction to: Certified first-order AC-unification and applications. <em>JAR</em>, <em>69</em>(1), 1. (<a href='https://doi.org/10.1007/s10817-024-09715-4'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  archive      = {J_JAR},
  author       = {Ayala-Rincón, Mauricio and Fernández, Maribel and Ferreira Silva, Gabriel and Kutsia, Temur and Nantes-Sobrinho, Daniele},
  doi          = {10.1007/s10817-024-09715-4},
  journal      = {Journal of Automated Reasoning},
  month        = {3},
  number       = {1},
  pages        = {1},
  shortjournal = {J. Auto. Reasoning},
  title        = {Correction to: Certified first-order AC-unification and applications},
  volume       = {69},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Fast, verified computation for HOL ITPs. <em>JAR</em>, <em>69</em>(1), 1-40. (<a href='https://doi.org/10.1007/s10817-025-09719-8'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We add an efficient function for computation to the kernels of higher-order logic interactive theorem provers. First, we develop and prove sound our approach for Candle. Candle is a port of HOL Light which has been proved sound with respect to the inference rules of its higher-order logic; we extend its implementation and soundness proof. Second, we replicate our now-verified implementation for HOL4 with only minor changes, and build additional automation for ease of use. The automation exists outside of the HOL4 kernel, and requires no additional trust. We exercise our new computation function and associated automation on the evaluation of the CakeML compiler backend within HOL4’s logic, demonstrating an order of magnitude speedup. This is an extended version of our previous conference paper [2], which described implementation and soundness proofs for Candle. Our HOL4 implementation and automation are new, as are the CakeML benchmarks.},
  archive      = {J_JAR},
  author       = {Abrahamsson, Oskar and Myreen, Magnus O. and Norrish, Michael and Kanabar, Hrutvik and Pohjola, Johannes Åman},
  doi          = {10.1007/s10817-025-09719-8},
  journal      = {Journal of Automated Reasoning},
  month        = {3},
  number       = {1},
  pages        = {1-40},
  shortjournal = {J. Auto. Reasoning},
  title        = {Fast, verified computation for HOL ITPs},
  volume       = {69},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Lessons for interactive theorem proving researchers from a survey of coq users. <em>JAR</em>, <em>69</em>(1), 1-29. (<a href='https://doi.org/10.1007/s10817-025-09720-1'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The Coq Community Survey 2022 was an online public survey of users of the Coq proof assistant conducted during February 2022. Broadly, the survey asked about use of Coq features, user interfaces, libraries, plugins, and tools, views on renaming Coq and Coq improvements, and also demographic data such as education and experience with Coq and other proof assistants and programming languages. The survey received 466 submitted responses, making it the largest survey of users of an interactive theorem prover (ITP) so far. We present the design of the survey, a summary of key results, and analysis of answers relevant to ITP technology development and usage. In particular, we analyze user characteristics associated with adoption of tools and libraries and make comparisons to adjacent software communities. Notably, we find that experience has significant impact on Coq user behavior, including on usage of tools, libraries, and integrated development environments (IDEs).},
  archive      = {J_JAR},
  author       = {de Almeida Borges, Ana and Casanueva Artís, Annalí and Falleri, Jean-Rémy and Gallego Arias, Emilio Jesús and Martin-Dorel, Érik and Palmskog, Karl and Serebrenik, Alexander and Zimmermann, Théo},
  doi          = {10.1007/s10817-025-09720-1},
  journal      = {Journal of Automated Reasoning},
  month        = {3},
  number       = {1},
  pages        = {1-29},
  shortjournal = {J. Auto. Reasoning},
  title        = {Lessons for interactive theorem proving researchers from a survey of coq users},
  volume       = {69},
  year         = {2025},
}
</textarea>
</details></li>
</ul>

</body>
</html>
